<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>惠善一的博客</title>
  
  <subtitle>SumBlog</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://huishanyi.club/"/>
  <updated>2020-09-02T23:40:30.477Z</updated>
  <id>http://huishanyi.club/</id>
  
  <author>
    <name>ShanYi Hui</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>浏览器渲染页面过程</title>
    <link href="http://huishanyi.club/2020/09/03/Web%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96/%E6%B5%8F%E8%A7%88%E5%99%A8%E6%B8%B2%E6%9F%93%E9%A1%B5%E9%9D%A2%E8%BF%87%E7%A8%8B/"/>
    <id>http://huishanyi.club/2020/09/03/Web性能优化/浏览器渲染页面过程/</id>
    <published>2020-09-02T22:10:15.000Z</published>
    <updated>2020-09-02T23:40:30.477Z</updated>
    
    <content type="html"><![CDATA[<p>&emsp;&emsp;用户在浏览器地址栏输入网址 到 页面加载完成，发生了什么？</p><ol><li><p>客户端地址栏输入网址；</p><ul><li>举个小白的例子：<code>小白（域名）</code>在一家<code>大公司（云厂商）</code>上班，有天<code>小红（客户端）</code>来看小白。</li></ul></li><li><p>域名解析；</p><ul><li>也叫DNS解析，云厂商将域名转化为 IP 地址，IP 才是网站真正的网络地址；</li><li>接着奏乐接着舞：可他到了小白的公司，发现找不到小白，于是去找<code>前台小姐姐（DNS解析）</code>，小姐姐查了查<code>小白的工位（IP）</code>，查到后告诉了小红。</li></ul></li><li><p>TCP “三次握手”；</p><ul><li>通过“三次握手”建立 TCP 连接，这里的三次是<code>建立连接成功</code>最少的通讯次数；</li><li>接着奏乐接着舞：<ol><li>第一次握手：小红到了办公室门口，有门禁，敲门后说：“<code>小白你在里面吗？我是小红。</code>”；</li><li>第二次握手：小白说：“<code>我在，你是那个小红啊？</code>”；</li><li>第三次握手：小红说：“<code>我是和你在东北玩泥巴的小红啊！</code>”，假设此时小白已认可小红。</li></ol></li></ul></li><li><p>客户端发送请求；</p><ul><li>请求页面数据（一般会存在多次请求，html，css，js，图片······）</li><li>接着奏乐接着舞：小红将<code>目光（接口）</code>转向<code>大方脸，大眼睛，大红唇（请求参数）</code>的小白。</li></ul></li><li><p>服务器端响应；</p><ul><li>服务器端接口收到请求，给予响应；</li><li>接着奏乐接着舞：小白发现自己被看着，站了起来（<code>小白现在的样子（响应数据）</code>已经通过<code>目光（接口）</code>展现在<code>小红的眼里、心里和深深脑海里（响应数据传递到客户端）</code>）。</li></ul></li><li><p>页面渲染；</p><ul><li><p>主要分为 DOM =&gt; CSSDOM =&gt; RenderTree =&gt; Layout =&gt; Painting =&gt; Display；</p></li><li><p>接着奏乐接着舞：小红和小白曾经在一起的经历<code>一一回想（逐步渲染）</code>，<code>完整的小白呈现（页面渲染完成。老子说过：只有躯壳的人是不完整的。）</code>。</p><p>更新中（将会详细剖析2到5阶段）······</p></li></ul></li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&amp;emsp;&amp;emsp;用户在浏览器地址栏输入网址 到 页面加载完成，发生了什么？&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;&lt;p&gt;客户端地址栏输入网址；&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;举个小白的例子：&lt;code&gt;小白（域名）&lt;/code&gt;在一家&lt;code&gt;大公司（云厂商）&lt;/code&gt;上班，
      
    
    </summary>
    
      <category term="Web性能优化" scheme="http://huishanyi.club/categories/Web%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96/"/>
    
    
      <category term="Web性能优化" scheme="http://huishanyi.club/tags/Web%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96/"/>
    
  </entry>
  
  <entry>
    <title>CSRF攻击</title>
    <link href="http://huishanyi.club/2020/07/15/Web%E5%AE%89%E5%85%A8/CSRF%E6%94%BB%E5%87%BB/"/>
    <id>http://huishanyi.club/2020/07/15/Web安全/CSRF攻击/</id>
    <published>2020-07-15T09:43:30.000Z</published>
    <updated>2020-07-18T12:32:13.349Z</updated>
    
    <content type="html"><![CDATA[<p>&emsp;&emsp;CSRF（Cross Site Request Forgery），跨站请求伪造， 是一种挟制用户在当前已登录的Web应用程序上执行非本意的操作的攻击方法。</p><h2 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h2><p>一个简易的假设如下，B 站伪造 A 站请求。</p><ol><li>用户使用浏览器访问 A 网站并登录；</li><li>登录成功后，网站 A 产生 Cookie 信息并返回给浏览器；</li><li>此时（A 站产生的 Cookie 存在时）访问 B 网站；</li><li>B 网站存在恶意代码（<code>&lt;img src=&quot;A 站支付请求&quot; /&gt;</code>）；</li><li>CSRF 成功（通过 B 站发送 A 站请求达到某些目的）。</li></ol><h2 id="条件"><a href="#条件" class="headerlink" title="条件"></a>条件</h2><ul><li>未进行请求来源校验；</li><li>Token 未进行动态化处理。</li></ul><h2 id="防御"><a href="#防御" class="headerlink" title="防御"></a>防御</h2><ul><li>Referer 检测：请求头中 Referer（用来记录请求来源地址） 值检测。</li><li>Token 校验（每次请求 Token 都在变，黑客无法获取可用 Token）<ul><li>请求参数中添加随机数（随机数可以存取在 session 中）</li><li>请求头中添加自定义属性</li><li>jwt（Json Web Token）</li></ul></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&amp;emsp;&amp;emsp;CSRF（Cross Site Request Forgery），跨站请求伪造， 是一种挟制用户在当前已登录的Web应用程序上执行非本意的操作的攻击方法。&lt;/p&gt;
&lt;h2 id=&quot;原理&quot;&gt;&lt;a href=&quot;#原理&quot; class=&quot;headerlink
      
    
    </summary>
    
      <category term="Web安全" scheme="http://huishanyi.club/categories/Web%E5%AE%89%E5%85%A8/"/>
    
    
      <category term="Web安全" scheme="http://huishanyi.club/tags/Web%E5%AE%89%E5%85%A8/"/>
    
  </entry>
  
  <entry>
    <title>XSS攻击</title>
    <link href="http://huishanyi.club/2020/07/15/Web%E5%AE%89%E5%85%A8/XSS%E6%94%BB%E5%87%BB/"/>
    <id>http://huishanyi.club/2020/07/15/Web安全/XSS攻击/</id>
    <published>2020-07-15T00:12:25.000Z</published>
    <updated>2020-07-18T08:46:29.866Z</updated>
    
    <content type="html"><![CDATA[<p>&emsp;&emsp;XSS（Cross Site Scripting） 攻击，跨站脚本攻击，因为缩写 CSS 和层叠样式表（Cascading Style Script）冲突，所以改为 XSS。<br>&emsp;&emsp;XSS 攻击者在 Web 页面插入恶意的脚本，当用户访问该页面时，嵌入到页面中的恶意脚本执行，从而攻击用户。</p><h2 id="非持久型XSS（反射型XSS）"><a href="#非持久型XSS（反射型XSS）" class="headerlink" title="非持久型XSS（反射型XSS）"></a>非持久型XSS（反射型XSS）</h2><p>通过特定手法（如电子邮件、网站论坛发布包装链接等），诱使用户去访问一个包含恶意代码的 URL，当受害者点击该链接的时候，恶意代码就会直接在受害者主机上的浏览器执行。</p><h3 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h3><p>一个简易的假设如下，输入一个脚本得到一个脚本结果。</p><ol><li>客户端访问指定页面（漏洞页面）;</li><li>在表单（搜索框）中输入 XSS 代码（<code>&lt;script&gt;alert(1)&lt;/script&gt;</code>），提交，即访问（<code>http://test.com/?=&lt;script&gt;alert(1)&lt;/script&gt;</code>）;</li><li>服务器收到请求，解析，并返回响应内容（含有 XSS 代码）；</li><li>浏览器解析响应（解析过程中会执行 XSS 代码）；</li><li>alert(1) 被执行。</li></ol><h3 id="条件"><a href="#条件" class="headerlink" title="条件"></a>条件</h3><ul><li>页面对特殊字符未转义</li></ul><h3 id="特点"><a href="#特点" class="headerlink" title="特点"></a>特点</h3><ul><li>即时性，不进行服务器存储；</li><li>需要诱使用户点击；</li><li>盗取用户信息。</li></ul><h3 id="防御"><a href="#防御" class="headerlink" title="防御"></a>防御</h3><ul><li>页面渲染的所有内容应该来自服务端；</li><li>对特殊字符做转义处理（传向服务器的数据和服务器传来的数据）；</li><li>对重要的 cookie 设置 httpOnly，避免 cookie 被客户端恶意的 JS 窃取。</li></ul><h2 id="持久型XSS（存储型XSS）"><a href="#持久型XSS（存储型XSS）" class="headerlink" title="持久型XSS（存储型XSS）"></a>持久型XSS（存储型XSS）</h2><p>通过特定手法（留言板），将XSS代码提交存储在服务器端（数据库，内存，文件系统等），下次请求目标页面时不用再提交 XSS 代码，而是从服务器解析之后加载出来。</p><h3 id="原理-1"><a href="#原理-1" class="headerlink" title="原理"></a>原理</h3><p>一个简易的假设如下，输入一个脚本存储到服务器，每次在请求指定页面时，都会直接读取解析到之前在该页面存储的 XSS 代码。</p><ol><li>客户端访问指定页面（漏洞页面）;</li><li>在表单（留言板）中输入 XSS 代码（<code>&lt;script&gt;alert(1)&lt;/script&gt;</code>），提交;</li><li>服务器收到请求，解析，并返回响应内容（含有 XSS 代码）；</li><li>浏览器解析响应（解析过程中会执行 XSS 代码）；</li><li>alert(1) 被执行；</li><li>再次访问该页面，浏览器自动解析留言内容；</li><li>alert(1) 被执行。</li></ol><h3 id="条件-1"><a href="#条件-1" class="headerlink" title="条件"></a>条件</h3><p>须同时满足以下条件。</p><ul><li>后端对前端的 POST 请求未做转义就直接入库；</li><li>后端从数据库中取出的数据未做转义就直接输出给前端；</li><li>前端拿到后端的数据未做转义就直接渲染成 DOM。</li></ul><h3 id="特点-1"><a href="#特点-1" class="headerlink" title="特点"></a>特点</h3><ul><li>植入在数据库中；</li><li>危害面广；</li><li>盗取用户信息。</li></ul><h3 id="防御-1"><a href="#防御-1" class="headerlink" title="防御"></a>防御</h3><p>对需要达成 XSS 的条件进行阻断。</p><ul><li>后端对前端的 POST 请求须做转义再入库；</li><li>后端从数据库中取出的数据须做转义再输出给前端；</li><li>前端拿到后端的数据须做转义再渲染成 DOM。</li></ul><h2 id="DOM-based-XSS"><a href="#DOM-based-XSS" class="headerlink" title="DOM-based XSS"></a>DOM-based XSS</h2><p>通过恶意脚本修改页面的 DOM 结构，是纯粹发生在客户端的攻击。</p><h3 id="原理-2"><a href="#原理-2" class="headerlink" title="原理"></a>原理</h3><ol><li>攻击者构造出特殊的URL、在其中可能包含恶意代码；</li><li>用户打开带有恶意代码的URL；</li><li>用户浏览器收到响应后解析执行。前端使用js取出url中的恶意代码并执行；</li><li>执行时，恶意代码窃取用户数据并发送到攻击者的网站中，那么攻击者网站拿到这些数据去冒充用户的行为操作。调用目标网站接口执行攻击者一些操作。</li></ol><h3 id="条件-2"><a href="#条件-2" class="headerlink" title="条件"></a>条件</h3><p>存在下列任何一个就有可能触发。</p><ul><li>使用document.write直接输出数据。</li><li>使用innerHTML直接输出数据。</li><li>使用location、location.href、location.replace、iframe.src、document.referer、window.name等。</li></ul><h3 id="特点-2"><a href="#特点-2" class="headerlink" title="特点"></a>特点</h3><ul><li>仅发生在客户端，服务器不参与。</li></ul><h3 id="防御-2"><a href="#防御-2" class="headerlink" title="防御"></a>防御</h3><ul><li>前端页面对特殊字符做转义；</li><li>少用满足条件的代码，尽可能做代码替换（纯文本时 innerText、textContent 比 innerHTML 更贴切）。</li></ul><h2 id="常见特殊字符转义表"><a href="#常见特殊字符转义表" class="headerlink" title="常见特殊字符转义表"></a>常见特殊字符转义表</h2><table><thead><tr><th align="center">特殊字符</th><th align="center">转义字符</th></tr></thead><tbody><tr><td align="center">&amp;</td><td align="center"><code>&amp;amp;</code></td></tr><tr><td align="center">&lt;</td><td align="center"><code>&amp;lt;</code></td></tr><tr><td align="center">&gt;</td><td align="center"><code>&amp;gt;</code></td></tr><tr><td align="center">空格</td><td align="center"><code>&amp;nbsp;</code></td></tr><tr><td align="center">‘</td><td align="center"><code>&amp;#39;</code></td></tr><tr><td align="center">“</td><td align="center"><code>&amp;quot;</code></td></tr><tr><td align="center">/</td><td align="center"><code>&amp;#x2F;</code></td></tr></tbody></table>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&amp;emsp;&amp;emsp;XSS（Cross Site Scripting） 攻击，跨站脚本攻击，因为缩写 CSS 和层叠样式表（Cascading Style Script）冲突，所以改为 XSS。&lt;br&gt;&amp;emsp;&amp;emsp;XSS 攻击者在 Web 页面插入恶意的脚本
      
    
    </summary>
    
      <category term="Web安全" scheme="http://huishanyi.club/categories/Web%E5%AE%89%E5%85%A8/"/>
    
    
      <category term="Web安全" scheme="http://huishanyi.club/tags/Web%E5%AE%89%E5%85%A8/"/>
    
  </entry>
  
  <entry>
    <title>强缓存和协商缓存</title>
    <link href="http://huishanyi.club/2020/07/14/Web%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96/%E5%BC%BA%E7%BC%93%E5%AD%98%E5%92%8C%E5%8D%8F%E5%95%86%E7%BC%93%E5%AD%98/"/>
    <id>http://huishanyi.club/2020/07/14/Web性能优化/强缓存和协商缓存/</id>
    <published>2020-07-14T06:57:42.000Z</published>
    <updated>2020-07-18T08:46:29.867Z</updated>
    
    <content type="html"><![CDATA[<p>&emsp;&emsp;缓存是什么？为什么要做缓存？常见的缓存机制有哪些？缓存是如何工作的？</p><h2 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h2><p>这里讨论的缓存为浏览器缓存。通过复用以前获取的资源来提高网站性能。 </p><h2 id="缓存优点"><a href="#缓存优点" class="headerlink" title="缓存优点"></a>缓存优点</h2><ul><li>减少对服务器的访问次数，减轻服务器压力；</li><li>节省带宽；</li><li>再次访问时提高了访问速度，提升了用户体验。</li></ul><h2 id="强缓存（本地缓存）"><a href="#强缓存（本地缓存）" class="headerlink" title="强缓存（本地缓存）"></a>强缓存（本地缓存）</h2><p>强制使用缓存方案，直接使用本地缓存，不与服务器通讯。成功状态码为 200。</p><h3 id="控制"><a href="#控制" class="headerlink" title="控制"></a>控制</h3><p>由 header 中的两个字段控制，分别为 expires 和 cache-control。</p><ul><li>expires（截止日期，http1.0规范）：客户端时间在截止日期之前的时间，都直接使用本地缓存（本地已存在缓存，客户端时间与服务器时间有偏差时，可能导致缓存失效）；</li><li>cache-control（缓存控制，优先级高于expires，http1.1规范）<ul><li>max-age=value：value 表示资源的最大有效时间的“秒数”，如果最新一次请求时间还小于资源第一次请求时间加上这个 value，则使用本地缓存，不会因为客户端时间与服务器时间有偏差而导致缓存失效；</li><li>public：表示客户端和代理服务器（如CDN）都可以缓存；</li><li>private（默认值）：表示只有客户端可以缓存；</li><li>no-cache：客户端缓存内容，但是是否使用缓存需要经过协商缓存来验证决定；</li><li>no-store：所有内容都不会被缓存，即不使用强缓存，也不使用协商缓存；</li><li>must-revalidate：如果缓存的内容失效，请求必须发送到服务器/代理以进行重新验证。</li></ul></li></ul><h2 id="弱缓存（协商缓存）"><a href="#弱缓存（协商缓存）" class="headerlink" title="弱缓存（协商缓存）"></a>弱缓存（协商缓存）</h2><p>强制缓存失效后，浏览器携带缓存标识向服务器发起请求，由服务器根据缓存标识决定是否使用缓存的过程。成功状态码为 304。</p><h3 id="控制-1"><a href="#控制-1" class="headerlink" title="控制"></a>控制</h3><p>由请求头中的 If-Modified-Since 和 If-None-Match 与响应头对应的 Last-Modified 和 ETag 来控制（必须成对使用才有效果）。</p><h3 id="Last-Modify-If-Modified-Since"><a href="#Last-Modify-If-Modified-Since" class="headerlink" title="Last-Modify/If-Modified-Since"></a>Last-Modify/If-Modified-Since</h3><p><strong>过程</strong></p><ul><li>第一次请求时，在 response header 中返回 Last-Modify，表示最后一次修改时间；</li><li>下次请求是，request header 中包含 If-Modify-Since，去询问服务器是不是还是上次那个最后修改时间；</li><li>如果还是上次的一样的时间，那么说明数据没有更新，服务端返回 304，浏览器直接从缓存中获取就行了；</li><li>如果不是上次不是上次的时间了，那么就返回数据，同时返回 Last-Modify。</li></ul><p><strong>缺点</strong></p><ul><li>Last-Modified 保存的是绝对时间，并且是精确到秒，所以如果资源在1秒内修改了多次的话，那就无法识别；</li><li>对于文件只改变了修改时间，内容不变，这时候也会使缓存失效，其实这个时候我们是不希望客户端重新请求的；</li><li>某些服务器不能精确的得到文件的最后修改时间。</li></ul><h3 id="ETag-If-None-Match"><a href="#ETag-If-None-Match" class="headerlink" title="ETag/If-None-Match"></a>ETag/If-None-Match</h3><p>这两个值是由服务器生成的资源唯一表示字符串，只要资源有变化这个值就会变化。判断过程同上，不同的是当服务器返回 304 时，由于 ETag 重新生成过，response header 中还是会将 ETag 返回，即使和原来的是一样的。</p><p><strong>优点</strong><br>除缓存的优点外，还解决了 Last-Modify/If-Modified-Since 的缺点。</p><p><strong>缺点</strong><br>ETag虽然能解决问题，但也并非完美，ETag 每次服务端生成都需要进行读写操作（因为要生成 hash），而 Last-Modified 只需要读取操作，ETag 消耗更大一些。</p><h3 id="同时使用"><a href="#同时使用" class="headerlink" title="同时使用"></a>同时使用</h3><p>Last-Modified 与 ETag 一起使用时，服务器会优先验证 ETag，一致的情况下，才会继续比对 Last-Modified，最后才决定是否返回 304。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&amp;emsp;&amp;emsp;缓存是什么？为什么要做缓存？常见的缓存机制有哪些？缓存是如何工作的？&lt;/p&gt;
&lt;h2 id=&quot;定义&quot;&gt;&lt;a href=&quot;#定义&quot; class=&quot;headerlink&quot; title=&quot;定义&quot;&gt;&lt;/a&gt;定义&lt;/h2&gt;&lt;p&gt;这里讨论的缓存为浏览器缓存。通过
      
    
    </summary>
    
      <category term="Web性能优化" scheme="http://huishanyi.club/categories/Web%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96/"/>
    
    
      <category term="Web性能优化" scheme="http://huishanyi.club/tags/Web%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96/"/>
    
  </entry>
  
  <entry>
    <title>JS操作字符串</title>
    <link href="http://huishanyi.club/2020/07/13/JS/JS%E6%93%8D%E4%BD%9C%E5%AD%97%E7%AC%A6%E4%B8%B2/"/>
    <id>http://huishanyi.club/2020/07/13/JS/JS操作字符串/</id>
    <published>2020-07-12T21:27:58.000Z</published>
    <updated>2020-07-18T08:46:29.863Z</updated>
    
    <content type="html"><![CDATA[<p>&emsp;&emsp;字符串用于存储和处理文本。</p><h2 id="创建字符串"><a href="#创建字符串" class="headerlink" title="创建字符串"></a>创建字符串</h2><p>用单引号 <strong>或</strong> 双引号包起来的字符（单引号双引号不可嵌套或交叉使用）。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> str = <span class="string">"Hello String!"</span>;</span><br><span class="line"><span class="keyword">var</span> str1 = <span class="string">'Hello String!'</span>;</span><br></pre></td></tr></table></figure><p><strong>注意：</strong>特殊字符需要使用‘\’转义。</p><ul><li>&#39;    单引号</li><li>&quot;    双引号</li><li>\    反斜杠</li><li>\n    换行</li><li>\r    回车</li><li>\t    tab(制表符)</li><li>\b    退格符</li><li>\f    换页符</li></ul><h2 id="字符串属性和方法"><a href="#字符串属性和方法" class="headerlink" title="字符串属性和方法"></a>字符串属性和方法</h2><h3 id="字符串长度"><a href="#字符串长度" class="headerlink" title="字符串长度"></a>字符串长度</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> str = <span class="string">"Hello String!"</span>;</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(str.length); <span class="comment">// 13</span></span><br></pre></td></tr></table></figure><h3 id="字符串指定位置字符"><a href="#字符串指定位置字符" class="headerlink" title="字符串指定位置字符"></a>字符串指定位置字符</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> str = <span class="string">"Hello String!"</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 返回第 1 个字符</span></span><br><span class="line"><span class="built_in">console</span>.log(str.charAt(<span class="number">0</span>)); <span class="comment">// H</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 返回第 1 个字符的 Unicode 编码</span></span><br><span class="line"><span class="built_in">console</span>.log(str.charCodeAt(<span class="number">0</span>)); <span class="comment">// 72</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 将 Unicode 编码转换为字符</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">String</span>.fromCharCode(<span class="number">72</span>)); <span class="comment">// H</span></span><br></pre></td></tr></table></figure><h3 id="字符串指定字符位置"><a href="#字符串指定字符位置" class="headerlink" title="字符串指定字符位置"></a>字符串指定字符位置</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> str = <span class="string">"Hello String!"</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// l 首次出现的位置</span></span><br><span class="line"><span class="keyword">var</span> address1 = str.indexOf(<span class="string">"l"</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// l 最后一次出现的位置</span></span><br><span class="line"><span class="keyword">var</span> address2 = str.lastIndexOf(<span class="string">"l"</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 查找不存在的字符会返回 -1</span></span><br><span class="line"><span class="keyword">var</span> address3 = str.lastIndexOf(<span class="string">"a"</span>);</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(address1, address2, address3); <span class="comment">// 2 3 -1</span></span><br></pre></td></tr></table></figure><h3 id="判断字符串开头"><a href="#判断字符串开头" class="headerlink" title="判断字符串开头"></a>判断字符串开头</h3><p>下列方法<strong>不会</strong>改变原字符串。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> str = <span class="string">"Hello World!"</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 判断 str 是否以 h 开头</span></span><br><span class="line"><span class="built_in">console</span>.log(str.startsWith(<span class="string">"h"</span>)); <span class="comment">// false</span></span><br></pre></td></tr></table></figure><h3 id="字符串拼接"><a href="#字符串拼接" class="headerlink" title="字符串拼接"></a>字符串拼接</h3><p>下列方法<strong>不会</strong>改变原字符串。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> str1 = <span class="string">"Hello"</span>,</span><br><span class="line">    str2 = <span class="string">" "</span>,</span><br><span class="line">    str3 = <span class="string">"World"</span>,</span><br><span class="line">    str4 = <span class="string">"!"</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 相当于 str1 + str2 + str3</span></span><br><span class="line"><span class="keyword">var</span> str = str1.concat(str2, str3, str4);</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(str); <span class="comment">// Hello World!</span></span><br></pre></td></tr></table></figure><h3 id="字符串重复"><a href="#字符串重复" class="headerlink" title="字符串重复"></a>字符串重复</h3><p>下列方法<strong>不会</strong>改变原字符串。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> str = <span class="string">"ab"</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// str 重复两遍</span></span><br><span class="line"><span class="built_in">console</span>.log(str.repeat(<span class="number">2</span>)); <span class="comment">// abab</span></span><br></pre></td></tr></table></figure><h3 id="字符串与正则"><a href="#字符串与正则" class="headerlink" title="字符串与正则"></a>字符串与正则</h3><p>下列方法<strong>不会</strong>改变原字符串。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> str = <span class="string">"abcdabcd"</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 整个字符串中查找，出现两次</span></span><br><span class="line"><span class="built_in">console</span>.log(str.match(<span class="regexp">/a/g</span>)); <span class="comment">// ["a", "a"]</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 整个字符串中替换 a 为 e</span></span><br><span class="line"><span class="keyword">var</span> str1 = str.replace(<span class="regexp">/a.*/g</span>, <span class="string">"e"</span>);</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(str, str1); <span class="comment">// abcdabcd ebcdebcd</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 查找指定字符所在位置，search 支持正则</span></span><br><span class="line"><span class="keyword">var</span> address1 = str.search(<span class="string">"a"</span>),</span><br><span class="line">    address2 = str.search(<span class="string">"e"</span>);</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(address1, address2); <span class="comment">// 0 -1</span></span><br></pre></td></tr></table></figure><h3 id="字符串分割成数组"><a href="#字符串分割成数组" class="headerlink" title="字符串分割成数组"></a>字符串分割成数组</h3><p>下列方法<strong>不会</strong>改变原字符串。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> str = <span class="string">"Hello World!"</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 以空格来划分数组</span></span><br><span class="line"><span class="keyword">var</span> strArr = str.split(<span class="string">" "</span>);</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(str, strArr); <span class="comment">// Hello World! ["Hello", "World!"]</span></span><br></pre></td></tr></table></figure><h3 id="字符串截取"><a href="#字符串截取" class="headerlink" title="字符串截取"></a>字符串截取</h3><p>下列方法<strong>不会</strong>改变原字符串。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> str = <span class="string">"Hello World!"</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// slice(start,end) 截取字符串，start 为起始位置，必填，最小为0；end 为结束位置，不填即代表至末尾；start &lt;= 截取值 &lt; end</span></span><br><span class="line"><span class="keyword">var</span> str1 = str.slice(<span class="number">0</span>,<span class="number">2</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// substr(start,length) 截取字符串，start 为起始位置，必填，最小为0；length 为截取长度，不填即代表至末尾；start &lt;= 截取值 &lt; start+length</span></span><br><span class="line"><span class="keyword">var</span> str2 = str.substr(<span class="number">1</span>,<span class="number">2</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// substring(start,end) 截取字符串，start 为起始位置，必填，最小为0；end 为结束位置，不填即代表至末尾；start &lt;= 截取值 &lt; end</span></span><br><span class="line"><span class="keyword">var</span> str3 = str.substring(<span class="number">2</span>,<span class="number">8</span>);</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(str, str1, str2, str3); <span class="comment">// Hello World!   He   el   ll0 w0</span></span><br></pre></td></tr></table></figure><h3 id="去字符串首尾空白"><a href="#去字符串首尾空白" class="headerlink" title="去字符串首尾空白"></a>去字符串首尾空白</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> str = <span class="string">"      Hello World!       "</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// trim() 去字符串首尾空白</span></span><br><span class="line"><span class="keyword">var</span> str1 = str.trim();</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">'-'</span>,str,<span class="string">'--'</span>,str1,<span class="string">'-'</span>); <span class="comment">// -       Hello World!        -- Hello World! -</span></span><br></pre></td></tr></table></figure><h3 id="字符串大小写转换"><a href="#字符串大小写转换" class="headerlink" title="字符串大小写转换"></a>字符串大小写转换</h3><p>下列方法<strong>不会</strong>改变原字符串。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> str = <span class="string">"Hello World!"</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 使用 toLowerCase() 将 str 转换为小写</span></span><br><span class="line"><span class="keyword">var</span> str1 = str.toLowerCase();</span><br><span class="line"></span><br><span class="line"><span class="comment">// 使用 toUpperCase() 将 str 转换为大写</span></span><br><span class="line"><span class="keyword">var</span> str2 = str.toUpperCase();</span><br><span class="line"></span><br><span class="line"><span class="comment">// 使用 toLocaleLowerCase() 将 str 转换为小写</span></span><br><span class="line"><span class="comment">// 可以识别本地主机语言（部分地域语言存在特有的大小写转换）来得出对应的小写</span></span><br><span class="line"><span class="keyword">var</span> str3 = str.toLocaleLowerCase();</span><br><span class="line"></span><br><span class="line"><span class="comment">// 使用 toLocaleUpperCase() 将 str 转换为大写</span></span><br><span class="line"><span class="comment">// 可以识别本地主机语言（部分地域语言存在特有的大小写转换）来得出对应的小写</span></span><br><span class="line"><span class="keyword">var</span> str4 = str.toLocaleUpperCase();</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(str,str1,str2,str3,str4); <span class="comment">// Hello World!   hello world!   HELLO WORLD!</span></span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&amp;emsp;&amp;emsp;字符串用于存储和处理文本。&lt;/p&gt;
&lt;h2 id=&quot;创建字符串&quot;&gt;&lt;a href=&quot;#创建字符串&quot; class=&quot;headerlink&quot; title=&quot;创建字符串&quot;&gt;&lt;/a&gt;创建字符串&lt;/h2&gt;&lt;p&gt;用单引号 &lt;strong&gt;或&lt;/strong&gt; 双
      
    
    </summary>
    
      <category term="前端" scheme="http://huishanyi.club/categories/%E5%89%8D%E7%AB%AF/"/>
    
    
      <category term="JS" scheme="http://huishanyi.club/tags/JS/"/>
    
  </entry>
  
  <entry>
    <title>JS操作数组</title>
    <link href="http://huishanyi.club/2020/07/13/JS/JS%E6%93%8D%E4%BD%9C%E6%95%B0%E7%BB%84/"/>
    <id>http://huishanyi.club/2020/07/13/JS/JS操作数组/</id>
    <published>2020-07-12T21:26:58.000Z</published>
    <updated>2020-07-18T08:46:29.864Z</updated>
    
    <content type="html"><![CDATA[<p>&emsp;&emsp;数组对象的作用是使用单独的变量名来存储一系列不限类型的值。</p><h2 id="创建数组"><a href="#创建数组" class="headerlink" title="创建数组"></a>创建数组</h2><h3 id="常规方式"><a href="#常规方式" class="headerlink" title="常规方式"></a>常规方式</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> myCars=<span class="keyword">new</span> <span class="built_in">Array</span>(); </span><br><span class="line">myCars[<span class="number">0</span>] = <span class="string">"Saab"</span>;       </span><br><span class="line">myCars[<span class="number">1</span>] = <span class="string">"Volvo"</span>;</span><br><span class="line">myCars[<span class="number">2</span>] = <span class="string">"BMW"</span>;</span><br></pre></td></tr></table></figure><h3 id="简洁方式"><a href="#简洁方式" class="headerlink" title="简洁方式"></a>简洁方式</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> myCars = <span class="keyword">new</span> <span class="built_in">Array</span>(<span class="string">"Saab"</span>,<span class="string">"Volvo"</span>,<span class="string">"BMW"</span>);</span><br></pre></td></tr></table></figure><h3 id="字面"><a href="#字面" class="headerlink" title="字面"></a>字面</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> myCars = [<span class="string">"Saab"</span>,<span class="string">"Volvo"</span>,<span class="string">"BMW"</span>];</span><br></pre></td></tr></table></figure><h2 id="访问数组"><a href="#访问数组" class="headerlink" title="访问数组"></a>访问数组</h2><p>通过指定数组名以及索引号码，你可以访问或修改某个特定的元素。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> myCars = [<span class="string">"Saab"</span>,<span class="string">"Volvo"</span>,<span class="string">"BMW"</span>];</span><br><span class="line"><span class="built_in">console</span>.log(myCars[<span class="number">0</span>]); <span class="comment">// 输出：Saab</span></span><br><span class="line"></span><br><span class="line">myCars[<span class="number">1</span>] = <span class="string">"Benz"</span>;</span><br><span class="line"><span class="built_in">console</span>.log(myCars); <span class="comment">// 输出：["Saab","Benz","BMW"]</span></span><br></pre></td></tr></table></figure><h2 id="数组属性和方法"><a href="#数组属性和方法" class="headerlink" title="数组属性和方法"></a>数组属性和方法</h2><h3 id="数组长度（数组中元素数量）"><a href="#数组长度（数组中元素数量）" class="headerlink" title="数组长度（数组中元素数量）"></a>数组长度（数组中元素数量）</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> myCars = [<span class="string">"Saab"</span>,<span class="string">"Volvo"</span>,<span class="string">"BMW"</span>];</span><br><span class="line"><span class="built_in">console</span>.log(myCars.length); <span class="comment">// 3</span></span><br></pre></td></tr></table></figure><h3 id="指定元素在数组中的位置"><a href="#指定元素在数组中的位置" class="headerlink" title="指定元素在数组中的位置"></a>指定元素在数组中的位置</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> myCars = [<span class="string">"Saab"</span>,<span class="string">"Volvo"</span>,<span class="string">"BMW"</span>];</span><br><span class="line"><span class="built_in">console</span>.log(myCars.indexOf(<span class="string">"Volvo"</span>)); <span class="comment">// 1</span></span><br></pre></td></tr></table></figure><h3 id="判断是否为数组"><a href="#判断是否为数组" class="headerlink" title="判断是否为数组"></a>判断是否为数组</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> arr = [];</span><br><span class="line"><span class="keyword">var</span> json = &#123;&#125;;</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">Array</span>.isArray(arr), <span class="built_in">Array</span>.isArray(json)); <span class="comment">// true false</span></span><br></pre></td></tr></table></figure><h3 id="数组转换为字符串"><a href="#数组转换为字符串" class="headerlink" title="数组转换为字符串"></a>数组转换为字符串</h3><p>下列方法<strong>不会</strong>改变原数组。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> num = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>];</span><br><span class="line"><span class="keyword">var</span> str1 = num.toString();</span><br><span class="line"><span class="keyword">var</span> str2 = num.join();</span><br><span class="line"></span><br><span class="line"><span class="comment">// Object.prototype.toString.call() 可检测任意数据类型</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">Object</span>.prototype.toString.call(str1), <span class="built_in">Object</span>.prototype.toString.call(str1)); <span class="comment">// [object String] [object String]</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(str1===str2); <span class="comment">// true</span></span><br></pre></td></tr></table></figure><h3 id="数组排序"><a href="#数组排序" class="headerlink" title="数组排序"></a>数组排序</h3><p>下列方法<strong>会</strong>改变原数组。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> num = [<span class="number">2</span>, <span class="number">1</span>, <span class="number">5</span>, <span class="number">4</span>, <span class="number">6</span>, <span class="number">3</span>];</span><br><span class="line"></span><br><span class="line"><span class="comment">// 反序原数组</span></span><br><span class="line"><span class="keyword">var</span> num1 = num.reverse();</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(num, num1) <span class="comment">// [3, 6, 4, 5, 1, 2] [3, 6, 4, 5, 1, 2]</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 正向排序数组</span></span><br><span class="line"><span class="keyword">var</span> num2 = num.sort();</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(num, num1, num2); <span class="comment">// [1, 2, 3, 4, 5, 6] [1, 2, 3, 4, 5, 6] [1, 2, 3, 4, 5, 6]，都指向 num</span></span><br></pre></td></tr></table></figure><h3 id="累加器"><a href="#累加器" class="headerlink" title="累加器"></a>累加器</h3><p>下列方法<strong>不会</strong>改变原数组。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> num = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>];</span><br><span class="line"></span><br><span class="line"><span class="comment">// 从左至右累加</span></span><br><span class="line"><span class="keyword">var</span> result = num.reduce(<span class="function">(<span class="params">total, item</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">`total:<span class="subst">$&#123;total&#125;</span> -- item:<span class="subst">$&#123;item&#125;</span> -- result:<span class="subst">$&#123;total+item&#125;</span>`</span>);</span><br><span class="line">    <span class="keyword">return</span> total + item</span><br><span class="line">&#125;)</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* total:1 -- item:2 -- result:3</span></span><br><span class="line"><span class="comment">* total:3 -- item:3 -- result:6</span></span><br><span class="line"><span class="comment">* total:6 -- item:4 -- result:10</span></span><br><span class="line"><span class="comment">* total:10 -- item:5 -- result:15</span></span><br><span class="line"><span class="comment">* total:15 -- item:6 -- result:21</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 从右至左累加</span></span><br><span class="line"><span class="keyword">var</span> result1 = num.reduceRight(<span class="function">(<span class="params">total, item</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">`total:<span class="subst">$&#123;total&#125;</span> -- item:<span class="subst">$&#123;item&#125;</span> -- result:<span class="subst">$&#123;total+item&#125;</span>`</span>);</span><br><span class="line">    <span class="keyword">return</span> total + item</span><br><span class="line">&#125;)</span><br><span class="line"><span class="comment">/** total:6 -- item:5 -- result:11</span></span><br><span class="line"><span class="comment">* total:11 -- item:4 -- result:15</span></span><br><span class="line"><span class="comment">* total:15 -- item:3 -- result:18</span></span><br><span class="line"><span class="comment">* total:18 -- item:2 -- result:20</span></span><br><span class="line"><span class="comment">* total:20 -- item:1 -- result:21</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(result, result1) <span class="comment">// 21 21</span></span><br></pre></td></tr></table></figure><h3 id="数组过滤"><a href="#数组过滤" class="headerlink" title="数组过滤"></a>数组过滤</h3><p>下列方法<strong>不会</strong>改变原数组。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> num = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>];</span><br><span class="line"></span><br><span class="line"><span class="comment">// 从 num 中获取一个大于 3 的数组</span></span><br><span class="line"><span class="keyword">var</span> num1 = num.filter(<span class="function"><span class="params">item</span> =&gt;</span> item&gt;<span class="number">3</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 从 num 中获取小于 4 的第一个元素</span></span><br><span class="line"><span class="keyword">var</span> num2 = num.find(<span class="function"><span class="params">item</span> =&gt;</span> item&lt;<span class="number">4</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 从 num 中获取小于 4 的第一个元素的索引</span></span><br><span class="line"><span class="keyword">var</span> num3 = num.findIndex(<span class="function"><span class="params">item</span> =&gt;</span> item&lt;<span class="number">4</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 从 num 中获取 2 元素的索引</span></span><br><span class="line"><span class="keyword">var</span> num4 = num.indexOf(<span class="number">2</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 从 num 中获取 2 元素最后一次出现的索引</span></span><br><span class="line"><span class="keyword">var</span> num5 = num.lastIndexOf(<span class="number">2</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 判断 num 数组中是否所有元素都大于 4</span></span><br><span class="line"><span class="keyword">var</span> judgement = num.every(<span class="function"><span class="params">item</span> =&gt;</span> item&gt;<span class="number">4</span>); <span class="comment">// false</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 判断 num 数组中是否含有元素大于 4</span></span><br><span class="line"><span class="keyword">var</span> judgement1 = num.some(<span class="function"><span class="params">item</span> =&gt;</span> item&gt;<span class="number">4</span>); <span class="comment">// true</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 判断 num 中是否有 1 元素</span></span><br><span class="line"><span class="keyword">var</span> judgement2 = num.includes(<span class="number">1</span>); <span class="comment">// true</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(num, num1, num2, num3, num4, num5, judgement, judgement1, judgement2); <span class="comment">// [1, 2, 3, 4, 5, 6] [4, 5, 6] 1 0 1 1 false true true</span></span><br></pre></td></tr></table></figure><h3 id="连接多个数组"><a href="#连接多个数组" class="headerlink" title="连接多个数组"></a>连接多个数组</h3><p>下列方法<strong>不会</strong>改变原数组。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> num1 = [<span class="number">1</span>, <span class="number">2</span>];</span><br><span class="line"><span class="keyword">var</span> num2 = [<span class="number">3</span>];</span><br><span class="line"><span class="keyword">var</span> num3 = [<span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>];</span><br><span class="line"><span class="keyword">var</span> num4 = num1.concat(num2,num3);</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(num1, num2, num3, num4) <span class="comment">// [1, 2] [3] [4, 5, 6] [1, 2, 3, 4, 5, 6]</span></span><br></pre></td></tr></table></figure><h3 id="添加元素至数组"><a href="#添加元素至数组" class="headerlink" title="添加元素至数组"></a>添加元素至数组</h3><p>下列方法<strong>会</strong>改变原数组。可添加任意数量。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> num = [<span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>];</span><br><span class="line"></span><br><span class="line"><span class="comment">// 推送至首位</span></span><br><span class="line"><span class="keyword">var</span> length1 = num.unshift(<span class="number">1</span>, <span class="number">2</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 推送至末位</span></span><br><span class="line"><span class="keyword">var</span> length2 = num.push(<span class="number">6</span>);</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(num, length1, length2); <span class="comment">// [1, 2, 3, 4, 5, 6] 5 6</span></span><br></pre></td></tr></table></figure><h3 id="删除数组中的元素"><a href="#删除数组中的元素" class="headerlink" title="删除数组中的元素"></a>删除数组中的元素</h3><p>下列方法<strong>会</strong>改变原数组。每次仅可删除一个。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> letter = [<span class="string">"a"</span>, <span class="string">"b"</span>, <span class="string">"c"</span>, <span class="string">"d"</span>, <span class="string">"e"</span>, <span class="string">"f"</span>];</span><br><span class="line"></span><br><span class="line"><span class="comment">// 删除首位元素</span></span><br><span class="line"><span class="keyword">var</span> element1 = letter.shift();</span><br><span class="line"></span><br><span class="line"><span class="comment">// 删除末位元素</span></span><br><span class="line"><span class="keyword">var</span> element2 = letter.pop();</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(letter, element1, element2); <span class="comment">// ["b", "c", "d", "e"] "a" "f"</span></span><br></pre></td></tr></table></figure><h3 id="数组截取替换"><a href="#数组截取替换" class="headerlink" title="数组截取替换"></a>数组截取替换</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> letter = [<span class="string">"a"</span>, <span class="string">"b"</span>, <span class="string">"c"</span>, <span class="string">"d"</span>, <span class="string">"e"</span>, <span class="string">"f"</span>];</span><br><span class="line"></span><br><span class="line"><span class="comment">// slice(start, end)；start &lt;= 取值 &lt; end，不改变原数组</span></span><br><span class="line"><span class="keyword">var</span> letter1 = letter.slice(<span class="number">0</span>, <span class="number">2</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 负数代表倒数，-1 为 e，-3 为 c</span></span><br><span class="line"><span class="keyword">var</span> letter2 = letter.slice(<span class="number">-3</span>, <span class="number">-1</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// slice(start)；start &lt;= 取值 &lt; 末尾</span></span><br><span class="line"><span class="keyword">var</span> letter3 = letter.slice(letter.length<span class="number">-1</span>);</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(letter,letter1,letter2,letter3); <span class="comment">// ["a", "b", "c", "d", "e", "f"] ["a", "b"] ["d", "e"] ["f"]</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// ******************************************************</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> letter = [<span class="string">"a"</span>, <span class="string">"b"</span>, <span class="string">"c"</span>, <span class="string">"d"</span>, <span class="string">"e"</span>, <span class="string">"f"</span>];</span><br><span class="line"></span><br><span class="line"><span class="comment">// 万能数组操作方法，会改变原数组</span></span><br><span class="line"><span class="comment">// splice(start, deleteNum, addElements)，从 start 位置删除 deleteNum 个，在 start 位置前添加 addElements</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 给 a 之前增加元素</span></span><br><span class="line"><span class="keyword">var</span> letter1 = letter.slice(<span class="number">0</span>);</span><br><span class="line">letter1.splice(<span class="number">0</span>, <span class="number">0</span>, <span class="string">"g"</span>, <span class="string">"g"</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 删除 a 和 b</span></span><br><span class="line"><span class="keyword">var</span> letter2= letter.slice(<span class="number">0</span>);</span><br><span class="line">letter2.splice(<span class="number">0</span>, <span class="number">2</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 修改 b 为 bb</span></span><br><span class="line"><span class="keyword">var</span> letter3 = letter.slice(<span class="number">0</span>);</span><br><span class="line">letter3.splice(<span class="number">1</span>, <span class="number">1</span>, <span class="string">"bb"</span>);</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(letter,letter1,letter2,letter3); <span class="comment">// ["a", "b", "c", "d", "e", "f"] ["g", "g", "a", "b", "c", "d", "e", "f"] ["c", "d", "e", "f"] ["a", "bb", "c", "d", "e", "f"]</span></span><br></pre></td></tr></table></figure><h3 id="数组遍历"><a href="#数组遍历" class="headerlink" title="数组遍历"></a>数组遍历</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> letter = [<span class="string">"a"</span>, <span class="string">"b"</span>, <span class="string">"c"</span>, <span class="string">""</span>];</span><br><span class="line"><span class="keyword">var</span> feArr = [],</span><br><span class="line">    mpArr = [];</span><br><span class="line"></span><br><span class="line"><span class="comment">// forEach 遍历数组</span></span><br><span class="line"><span class="keyword">var</span> forEachArr = letter.forEach(<span class="function">(<span class="params">item, index</span>) =&gt;</span> &#123;</span><br><span class="line">    feArr.push(index+item);</span><br><span class="line">    <span class="keyword">return</span> index+item;</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="comment">// map 遍历数组</span></span><br><span class="line"><span class="keyword">var</span> mapArr = letter.map(<span class="function">(<span class="params">item, index</span>) =&gt;</span> &#123;</span><br><span class="line">    mpArr.push(index+item);</span><br><span class="line">    <span class="keyword">return</span> index+item;</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(letter, feArr, forEachArr, mpArr, mapArr); </span><br><span class="line"><span class="comment">// ["a", "b", "c", ""] ["0a", "1b", "2c", "3"] undefined ["0a", "1b", "2c", "3"] ["0a", "1b", "2c", "3"]</span></span><br></pre></td></tr></table></figure><h2 id="数组深拷贝"><a href="#数组深拷贝" class="headerlink" title="数组深拷贝"></a>数组深拷贝</h2><p>数组为指向型数据。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> num = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>];</span><br><span class="line"></span><br><span class="line"><span class="comment">//声明的 num1 指向 num，即修改 num 或 num1 任何一个，都会两个一起改变</span></span><br><span class="line"><span class="keyword">var</span> num1 = num;</span><br><span class="line"></span><br><span class="line">num[<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(num,num1); <span class="comment">// [0, 2, 3] [0, 2, 3]</span></span><br><span class="line"></span><br><span class="line">num1[<span class="number">0</span>] = <span class="number">4</span>;</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(num, num1); <span class="comment">// [4, 2, 3] [4, 2, 3]</span></span><br></pre></td></tr></table></figure><h3 id="slice-0"><a href="#slice-0" class="headerlink" title="slice(0)"></a>slice(0)</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> num = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>];</span><br><span class="line"></span><br><span class="line"><span class="comment">//截取一个数组，从初始位置到结束</span></span><br><span class="line"><span class="keyword">var</span> num1 = num.slice(<span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">num[<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(num,num1); <span class="comment">// [0, 2, 3] [1, 2, 3]</span></span><br><span class="line"></span><br><span class="line">num1[<span class="number">0</span>] = <span class="number">4</span>;</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(num, num1); <span class="comment">// [0, 2, 3] [4, 2, 3]</span></span><br></pre></td></tr></table></figure><h3 id="concat"><a href="#concat" class="headerlink" title="concat()"></a>concat()</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> num = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>];</span><br><span class="line"></span><br><span class="line"><span class="comment">//声明的 num1 指向 num，即修改 num 或 num1 任何一个，都会两个一起改变</span></span><br><span class="line"><span class="keyword">var</span> num1 = num.concat();</span><br><span class="line"></span><br><span class="line">num[<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(num,num1); <span class="comment">// [0, 2, 3] [0, 2, 3]</span></span><br><span class="line"></span><br><span class="line">num1[<span class="number">0</span>] = <span class="number">4</span>;</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(num, num1); <span class="comment">// [0, 2, 3] [4, 2, 3]</span></span><br></pre></td></tr></table></figure><h3 id="…"><a href="#…" class="headerlink" title="[…[]]"></a>[…[]]</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> num = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>];</span><br><span class="line"></span><br><span class="line"><span class="comment">//声明的 num1 指向 num，即修改 num 或 num1 任何一个，都会两个一起改变</span></span><br><span class="line"><span class="keyword">var</span> num1 = [...num];</span><br><span class="line"></span><br><span class="line">num[<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(num,num1); <span class="comment">// [0, 2, 3] [0, 2, 3]</span></span><br><span class="line"></span><br><span class="line">num1[<span class="number">0</span>] = <span class="number">4</span>;</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(num, num1); <span class="comment">// [0, 2, 3] [4, 2, 3]</span></span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&amp;emsp;&amp;emsp;数组对象的作用是使用单独的变量名来存储一系列不限类型的值。&lt;/p&gt;
&lt;h2 id=&quot;创建数组&quot;&gt;&lt;a href=&quot;#创建数组&quot; class=&quot;headerlink&quot; title=&quot;创建数组&quot;&gt;&lt;/a&gt;创建数组&lt;/h2&gt;&lt;h3 id=&quot;常规方式&quot;&gt;&lt;a
      
    
    </summary>
    
      <category term="前端" scheme="http://huishanyi.club/categories/%E5%89%8D%E7%AB%AF/"/>
    
    
      <category term="JS" scheme="http://huishanyi.club/tags/JS/"/>
    
  </entry>
  
  <entry>
    <title>Promise</title>
    <link href="http://huishanyi.club/2020/07/08/JS/Promise/"/>
    <id>http://huishanyi.club/2020/07/08/JS/Promise/</id>
    <published>2020-07-07T21:49:44.000Z</published>
    <updated>2020-07-18T08:46:29.865Z</updated>
    
    <content type="html"><![CDATA[<p>&emsp;&emsp;Promise <strong>对象</strong>用于表示一个<strong>异步操作</strong>的最终完成 (或失败), 及其<strong>结果</strong>值。<a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Promise" target="_blank" rel="noopener">推荐文档</a></p><h2 id="简单使用"><a href="#简单使用" class="headerlink" title="简单使用"></a>简单使用</h2><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> promise1 = <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="comment">// resolve，异步操作完成结果，指引本函数执行 then 中的代码</span></span><br><span class="line">    <span class="comment">// reject，异步操作失败结果，指引本函数执行 catch 中的代码</span></span><br><span class="line">    <span class="comment">// *** resolve 或 reject 任何一个执行，即代表本函数逻辑执行完成，不再执行本函数的其它代码</span></span><br><span class="line">    resolve(<span class="string">'It is value.'</span>)</span><br><span class="line">    setTimeout(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">        reject(<span class="string">'It is err.'</span>)</span><br><span class="line">    &#125;, <span class="number">3000</span>);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">promise1.then(<span class="function">(<span class="params">value</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(value);</span><br><span class="line">    <span class="comment">// 输出（resolve 执行，reject 不执行）: "It is value."</span></span><br><span class="line">&#125;).catch(<span class="function">(<span class="params">err</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(err);</span><br><span class="line">    <span class="comment">// 输出（reject 执行，resolve 不执行）: "It is err."</span></span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(promise1);</span><br><span class="line"><span class="comment">// 输出: [object Promise]</span></span><br></pre></td></tr></table></figure><h2 id="参数"><a href="#参数" class="headerlink" title="参数"></a>参数</h2><p>executor [ɪɡˈzekjətər]，执行器，是 Promise 的唯一参数。  </p><p>executor 是一个函数，这个函数包含两个参数，分别为 resolve 和 reject。<br>resolve 代表 Promise 执行完成，Promise 状态变为 fulfilled，并执行 then 回调返回执行结果；<br>reject 代表 Promise 执行失败，Promise 状态变为 rejected，并执行 catch 回调抛出错误信息；</p><h2 id="状态"><a href="#状态" class="headerlink" title="状态"></a>状态</h2><p>Promise 有 3 种状态，分别为 pending、fulfilled 和 rejected。</p><h3 id="pending"><a href="#pending" class="headerlink" title="pending"></a>pending</h3><p>初始状态，既不是成功，也不是失败状态。</p><h3 id="fulfilled"><a href="#fulfilled" class="headerlink" title="fulfilled"></a>fulfilled</h3><p>意味着操作成功完成；</p><h3 id="rejected"><a href="#rejected" class="headerlink" title="rejected"></a>rejected</h3><p>意味着操作失败。</p><p><em>注意：如果一个 promise 对象处在 fulfilled 或 rejected 状态而不是 pending 状态，那么它也可以被称为 settled 状态。你可能也会听到一个术语 resolved ，它表示 promise 对象处于 settled 状态。</em></p><h2 id="链式调用"><a href="#链式调用" class="headerlink" title="链式调用"></a>链式调用</h2><p>因为 Promise.prototype.then 和  Promise.prototype.catch 方法返回promise 对象， 所以它们可以被链式调用。</p><p><img src="/images/promises.png" alt="Promise 链式调用" title="Promise 链式调用"></p><h2 id="属性"><a href="#属性" class="headerlink" title="属性"></a>属性</h2><ul><li>Promise.length：其值总是为 1 (构造器参数的数目)；</li><li>Promise.prototype：表示 Promise 构造器的原型。</li></ul><h2 id="方法"><a href="#方法" class="headerlink" title="方法"></a>方法</h2><h3 id="Promise-all-iterable"><a href="#Promise-all-iterable" class="headerlink" title="Promise.all(iterable)"></a>Promise.all(iterable)</h3><p>Promise.all(iterable) 方法返回一个 Promise 实例，此实例在 iterable（一个可迭代对象，Array 或 String） 参数内所有的 promise 都“完成（resolved）”或参数中不包含 promise 时回调完成（resolve）；如果参数中  promise 有一个失败（rejected），此实例回调失败（reject），失败的原因是第一个失败 promise 的结果。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> promise1 = <span class="built_in">Promise</span>.resolve(<span class="number">3</span>);</span><br><span class="line"><span class="keyword">const</span> promise2 = <span class="number">42</span>;</span><br><span class="line"><span class="keyword">const</span> promise3 = <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">  setTimeout(resolve, <span class="number">2000</span>, <span class="string">'foo'</span>);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="built_in">Promise</span>.all([promise1, promise2, promise3]).then(<span class="function">(<span class="params">values</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(values);</span><br><span class="line">&#125;);</span><br><span class="line"><span class="comment">// 2s 后输出: Array [3, 42, "foo"]</span></span><br></pre></td></tr></table></figure><p><strong>返回值</strong></p><ul><li>resolved<ul><li>参数为空的可迭代对象，返回一个已完成（already resolved）状态的 Promise；</li><li>参数不包含任何 promise，返回一个异步完成（asynchronously resolved） Promise。</li></ul></li><li>rejected<ul><li>无参数，返回一个 rejected 状态的 Promise，并报错<code>Uncaught (in promise) TypeError: Cannot read property &#39;Symbol(Symbol.iterator)&#39; of undefined</code>；</li><li>参数中存在 rejected，返回一个 rejected 状态的 Promise，并报错指出在参数中 rejected 的位置。</li></ul></li><li>其他情况返回一个处理中（pending）的Promise。</li></ul><h3 id="Promise-race-iterable"><a href="#Promise-race-iterable" class="headerlink" title="Promise.race(iterable)"></a>Promise.race(iterable)</h3><p>Promise.race(iterable) 方法返回一个 promise，一旦迭代器中的某个 promise <strong>解决 或 拒绝</strong>，返回的 promise 就会 解决 或 拒绝。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> promise1 = <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">  setTimeout(resolve, <span class="number">3000</span>, <span class="string">'one'</span>);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> promise2 = <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">  setTimeout(resolve, <span class="number">1000</span>, <span class="string">'two'</span>);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="built_in">Promise</span>.race([promise1, promise2]).then(<span class="function">(<span class="params">value</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(value);</span><br><span class="line">&#125;);</span><br><span class="line"><span class="comment">// 1s 后输出: "two"</span></span><br></pre></td></tr></table></figure><h3 id="Promise-reject-reason"><a href="#Promise-reject-reason" class="headerlink" title="Promise.reject(reason)"></a>Promise.reject(reason)</h3><p>Promise.reject(reason) 方法返回一个带有拒绝原因的Promise对象。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">resolved</span>(<span class="params">result</span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'Resolved'</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">rejected</span>(<span class="params">result</span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.error(result);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">Promise</span>.reject(<span class="keyword">new</span> <span class="built_in">Error</span>(<span class="string">'fail'</span>)).then(resolved, rejected);</span><br><span class="line"><span class="comment">// 输出: Error: fail</span></span><br></pre></td></tr></table></figure><h3 id="Promise-resolve-value"><a href="#Promise-resolve-value" class="headerlink" title="Promise.resolve(value)"></a>Promise.resolve(value)</h3><p>Promise.resolve(value)方法返回一个以给定值解析后的Promise 对象。如果这个值是一个 promise ，那么将返回这个 promise ；如果这个值是thenable（即带有”then” 方法），返回的promise会“跟随”这个thenable的对象，采用它的最终状态；否则返回的promise将以此值完成。此函数将类promise对象的多层嵌套展平。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Resolve一个thenable对象</span></span><br><span class="line"><span class="keyword">var</span> p1 = <span class="built_in">Promise</span>.resolve(&#123; </span><br><span class="line">  then: <span class="function"><span class="keyword">function</span>(<span class="params">onFulfill, onReject</span>) </span>&#123; onFulfill(<span class="string">"fulfilled!"</span>); &#125;</span><br><span class="line">&#125;);</span><br><span class="line"><span class="built_in">console</span>.log(p1 <span class="keyword">instanceof</span> <span class="built_in">Promise</span>) <span class="comment">// true, 这是一个Promise对象</span></span><br><span class="line"></span><br><span class="line">p1.then(<span class="function"><span class="keyword">function</span>(<span class="params">v</span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(v); <span class="comment">// 输出"fulfilled!"</span></span><br><span class="line">  &#125;, <span class="function"><span class="keyword">function</span>(<span class="params">e</span>) </span>&#123;</span><br><span class="line">    <span class="comment">// 不会被调用</span></span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="comment">// Thenable在callback之前抛出异常</span></span><br><span class="line"><span class="comment">// Promise rejects</span></span><br><span class="line"><span class="keyword">var</span> thenable = &#123; <span class="attr">then</span>: <span class="function"><span class="keyword">function</span>(<span class="params">resolve</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">TypeError</span>(<span class="string">"Throwing"</span>);</span><br><span class="line">  resolve(<span class="string">"Resolving"</span>);</span><br><span class="line">&#125;&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> p2 = <span class="built_in">Promise</span>.resolve(thenable);</span><br><span class="line">p2.then(<span class="function"><span class="keyword">function</span>(<span class="params">v</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// 不会被调用</span></span><br><span class="line">&#125;, <span class="function"><span class="keyword">function</span>(<span class="params">e</span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(e); <span class="comment">// TypeError: Throwing</span></span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="comment">// Thenable在callback之后抛出异常</span></span><br><span class="line"><span class="comment">// Promise resolves</span></span><br><span class="line"><span class="keyword">var</span> thenable = &#123; <span class="attr">then</span>: <span class="function"><span class="keyword">function</span>(<span class="params">resolve</span>) </span>&#123;</span><br><span class="line">  resolve(<span class="string">"Resolving"</span>);</span><br><span class="line">  <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">TypeError</span>(<span class="string">"Throwing"</span>);</span><br><span class="line">&#125;&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> p3 = <span class="built_in">Promise</span>.resolve(thenable);</span><br><span class="line">p3.then(<span class="function"><span class="keyword">function</span>(<span class="params">v</span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(v); <span class="comment">// 输出"Resolving"</span></span><br><span class="line">&#125;, <span class="function"><span class="keyword">function</span>(<span class="params">e</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// 不会被调用</span></span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><h2 id="原型"><a href="#原型" class="headerlink" title="原型"></a>原型</h2><p>Promise.prototype.constructor()，返回被创建的实例函数.  默认为 Promise 函数。</p><h3 id="Promise-prototype-catch-onRejected"><a href="#Promise-prototype-catch-onRejected" class="headerlink" title="Promise.prototype.catch(onRejected)"></a>Promise.prototype.catch(onRejected)</h3><p>catch() 方法返回一个Promise，并且处理拒绝的情况。它的行为与调用 Promise.prototype.then(undefined, onRejected) 相同。</p><p><strong>无法捕获错误示例</strong></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//创建一个新的 Promise ，且已决议</span></span><br><span class="line"><span class="keyword">var</span> p1 = <span class="built_in">Promise</span>.resolve(<span class="string">"calling next"</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> p2 = p1.catch(<span class="function"><span class="keyword">function</span> (<span class="params">reason</span>) </span>&#123;</span><br><span class="line">    <span class="comment">//这个方法永远不会调用</span></span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">"catch p1!"</span>);</span><br><span class="line">    <span class="built_in">console</span>.log(reason);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">p2.then(<span class="function"><span class="keyword">function</span> (<span class="params">value</span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">"next promise's onFulfilled"</span>); <span class="comment">/* next promise's onFulfilled */</span></span><br><span class="line">    <span class="built_in">console</span>.log(value); <span class="comment">/* calling next */</span></span><br><span class="line">&#125;, <span class="function"><span class="keyword">function</span> (<span class="params">reason</span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">"next promise's onRejected"</span>);</span><br><span class="line">    <span class="built_in">console</span>.log(reason);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 在异步函数中抛出的错误不会被catch捕获到</span></span><br><span class="line"><span class="keyword">var</span> p3 = <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function"><span class="keyword">function</span>(<span class="params">resolve, reject</span>) </span>&#123;</span><br><span class="line">  setTimeout(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">throw</span> <span class="string">'Uncaught Exception!'</span>;</span><br><span class="line">  &#125;, <span class="number">1000</span>);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">p3.catch(<span class="function"><span class="keyword">function</span>(<span class="params">e</span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(e); <span class="comment">// 不会执行</span></span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 在resolve()后面抛出的错误会被忽略</span></span><br><span class="line"><span class="keyword">var</span> p4 = <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function"><span class="keyword">function</span>(<span class="params">resolve, reject</span>) </span>&#123;</span><br><span class="line">  resolve();</span><br><span class="line">  <span class="keyword">throw</span> <span class="string">'Silenced Exception!'</span>;</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">p4.catch(<span class="function"><span class="keyword">function</span>(<span class="params">e</span>) </span>&#123;</span><br><span class="line">   <span class="built_in">console</span>.log(e); <span class="comment">// 不会执行</span></span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><h3 id="Promise-prototype-then-onFulfilled-onRejected"><a href="#Promise-prototype-then-onFulfilled-onRejected" class="headerlink" title="Promise.prototype.then(onFulfilled, onRejected)"></a>Promise.prototype.then(onFulfilled, onRejected)</h3><p>then() 方法返回一个 Promise。它最多需要有两个参数：Promise 的成功和失败情况的回调函数。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> promise1 = <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="comment">//resolve('Success!');</span></span><br><span class="line">  reject(<span class="string">'Filled!'</span>)</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">promise1.then(<span class="function">(<span class="params">value</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(value);</span><br><span class="line">  <span class="comment">// resolve 先执行则输出: "Success!"</span></span><br><span class="line">&#125;，(err)=&gt;&#123;</span><br><span class="line"><span class="built_in">console</span>.log(err)</span><br><span class="line">    <span class="comment">// reject 先执行则输出: "Filled!"</span></span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="comment">// *********** 与上方等同 ************</span></span><br><span class="line">promise1.then(<span class="function">(<span class="params">value</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(value);</span><br><span class="line">  <span class="comment">// resolve 先执行则输出: "Success!"</span></span><br><span class="line">&#125;).catch(<span class="function">(<span class="params">err</span>)=&gt;</span>&#123;</span><br><span class="line"><span class="built_in">console</span>.log(err)</span><br><span class="line">    <span class="comment">// reject 先执行则输出: "Filled!"</span></span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><h3 id="Promise-prototype-finally-onFinally"><a href="#Promise-prototype-finally-onFinally" class="headerlink" title="Promise.prototype.finally(onFinally)"></a>Promise.prototype.finally(onFinally)</h3><p>finally() 方法返回一个Promise。在promise结束时，无论结果是fulfilled或者是rejected，都会执行指定的回调函数。<br>这避免了同样的语句需要在then()和catch()中各写一次的情况（例如，发一次请求，无论请求成功与否，都需要记录一次请求总次数）。</p><p><strong>示例</strong></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">Promise</span>.resolve(<span class="number">2</span>).then(<span class="function"><span class="params">()</span> =&gt;</span> &#123;&#125;, () =&gt; &#123;&#125;) <span class="comment">// resolve 的结果为 undefined</span></span><br><span class="line"><span class="built_in">Promise</span>.resolve(<span class="number">2</span>).finally(<span class="function"><span class="params">()</span> =&gt;</span> &#123;&#125;) <span class="comment">// resolve 的结果为 2</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">Promise</span>.reject(<span class="number">3</span>).then(<span class="function"><span class="params">()</span> =&gt;</span> &#123;&#125;, () =&gt; &#123;&#125;) <span class="comment">// resolve 的结果为 undefined</span></span><br><span class="line"><span class="built_in">Promise</span>.reject(<span class="number">3</span>).finally(<span class="function"><span class="params">()</span> =&gt;</span> &#123;&#125;) <span class="comment">// rejected 的结果为 3</span></span><br></pre></td></tr></table></figure><h2 id="实例"><a href="#实例" class="headerlink" title="实例"></a>实例</h2><p>该实例为使用 XHR 加载图像。<br><a href="https://github.com/mdn/js-examples/tree/master/promises-test" target="_blank" rel="noopener">源码及步骤详解</a><br><a href="https://mdn.github.io/js-examples/promises-test/" target="_blank" rel="noopener">演示地址</a></p><h2 id="手写-Promise"><a href="#手写-Promise" class="headerlink" title="手写 Promise"></a>手写 Promise</h2><p>通过手写 Promise 来深刻理解 Promise。</p><h3 id="参数及状态设计"><a href="#参数及状态设计" class="headerlink" title="参数及状态设计"></a>参数及状态设计</h3><ul><li>参数：executor，详细请看 <a href="#参数">参数</a>；</li><li>状态：pending、fulfilled（resolved）和 rejected，详细请看 <a href="#状态">状态</a>。</li></ul><h4 id="设计代码"><a href="#设计代码" class="headerlink" title="设计代码"></a>设计代码</h4><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyPromise</span> </span>&#123;</span><br><span class="line">  <span class="keyword">constructor</span>(executor) &#123;</span><br><span class="line">    <span class="comment">// 默认为 pending （等待）状态</span></span><br><span class="line">    <span class="keyword">this</span>.PromiseStatus = <span class="string">'pending'</span>;</span><br><span class="line">    <span class="comment">// 默认为值为 undefined</span></span><br><span class="line">    <span class="keyword">this</span>.PromiseValue = <span class="literal">undefined</span>;</span><br><span class="line">    <span class="comment">// executor 中的 resolve 方法</span></span><br><span class="line">    <span class="keyword">let</span> resolve = <span class="function"><span class="params">value</span> =&gt;</span> &#123;</span><br><span class="line">      <span class="keyword">if</span>(<span class="keyword">this</span>.PromiseStatus === <span class="string">'pending'</span>)&#123;</span><br><span class="line">        <span class="comment">// 将 MyPromise 状态更改为 resolved</span></span><br><span class="line">        <span class="keyword">this</span>.PromiseStatus = <span class="string">'resolved'</span>;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="comment">// 更新 MyPromise 的 value</span></span><br><span class="line">      <span class="keyword">this</span>.PromiseValue = value;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// executor 中的 reject 方法</span></span><br><span class="line">    <span class="keyword">let</span> reject = <span class="function"><span class="params">reason</span> =&gt;</span> &#123;</span><br><span class="line">      <span class="keyword">if</span>(<span class="keyword">this</span>.PromiseStatus === <span class="string">'pending'</span>)&#123;</span><br><span class="line">        <span class="comment">// 将 MyPromise 状态更改为 rejected</span></span><br><span class="line">        <span class="keyword">this</span>.PromiseStatus = <span class="string">'rejected'</span></span><br><span class="line">      &#125;</span><br><span class="line">      <span class="comment">// 更新 MyPromise 的 value</span></span><br><span class="line">      <span class="keyword">this</span>.PromiseValue = reason;</span><br><span class="line">      <span class="comment">// 抛出错误信息</span></span><br><span class="line">      <span class="built_in">console</span>.error(reason);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 捕获，若 executor 报错，直接执行 reject</span></span><br><span class="line">    <span class="keyword">try</span>&#123;</span><br><span class="line">      executor(resolve, reject)</span><br><span class="line">    &#125;<span class="keyword">catch</span>(err) &#123;</span><br><span class="line">      reject(err)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="测试代码"><a href="#测试代码" class="headerlink" title="测试代码"></a>测试代码</h4><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> p1 = <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function"><span class="params">()</span> =&gt;</span> &#123;&#125;)</span><br><span class="line"><span class="keyword">var</span> p2 = <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;resolve(<span class="number">123</span>)&#125;)</span><br><span class="line"><span class="keyword">var</span> p3 = <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;reject(<span class="number">123</span>)&#125;)</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> mp1 = <span class="keyword">new</span> MyPromise(<span class="function"><span class="params">()</span> =&gt;</span> &#123;&#125;)</span><br><span class="line"><span class="keyword">var</span> mp2 = <span class="keyword">new</span> MyPromise(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;resolve(<span class="number">123</span>)&#125;)</span><br><span class="line"><span class="keyword">var</span> mp3 = <span class="keyword">new</span> MyPromise(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;reject(<span class="number">123</span>)&#125;)</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(p1,mp1)</span><br><span class="line"><span class="built_in">console</span>.log(p2,mp2)</span><br><span class="line"><span class="built_in">console</span>.log(p3,mp3)</span><br></pre></td></tr></table></figure><h4 id="测试截图"><a href="#测试截图" class="headerlink" title="测试截图"></a>测试截图</h4><p>复制代码到控制台试试吧<del>~</del>  </p><p><img src="/images/write_promise1.png" alt="手写 Promise 1" title="手写 Promise 1"></p><h3 id="then-方法设计"><a href="#then-方法设计" class="headerlink" title="then 方法设计"></a>then 方法设计</h3><p>then() 方法有两个参数，onFulfilled 和 onRejected，详细请看 <a href="#Promise-prototype-then-onFulfilled-onRejected">Promise.prototype.then</a>。</p><h4 id="设计代码-1"><a href="#设计代码-1" class="headerlink" title="设计代码"></a>设计代码</h4><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyPromise</span> </span>&#123;</span><br><span class="line">  <span class="keyword">constructor</span>(executor) &#123;</span><br><span class="line">    <span class="comment">// 默认为 pending （等待）状态</span></span><br><span class="line">    <span class="keyword">this</span>.PromiseStatus = <span class="string">'pending'</span>;</span><br><span class="line">    <span class="comment">// 默认为值为 undefined</span></span><br><span class="line">    <span class="keyword">this</span>.PromiseValue = <span class="literal">undefined</span>;</span><br><span class="line">    <span class="comment">// executor 中的 resolve 方法</span></span><br><span class="line">    <span class="keyword">let</span> resolve = <span class="function"><span class="params">value</span> =&gt;</span> &#123;</span><br><span class="line">      <span class="keyword">if</span>(<span class="keyword">this</span>.PromiseStatus === <span class="string">'pending'</span>)&#123;</span><br><span class="line">        <span class="comment">// 将 MyPromise 状态更改为 resolved</span></span><br><span class="line">        <span class="keyword">this</span>.PromiseStatus = <span class="string">'resolved'</span>;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="comment">// 更新 MyPromise 的 value</span></span><br><span class="line">      <span class="keyword">this</span>.PromiseValue = value;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// executor 中的 reject 方法</span></span><br><span class="line">    <span class="keyword">let</span> reject = <span class="function"><span class="params">reason</span> =&gt;</span> &#123;</span><br><span class="line">      <span class="keyword">if</span>(<span class="keyword">this</span>.PromiseStatus === <span class="string">'pending'</span>)&#123;</span><br><span class="line">        <span class="comment">// 将 MyPromise 状态更改为 rejected</span></span><br><span class="line">        <span class="keyword">this</span>.PromiseStatus = <span class="string">'rejected'</span>;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="comment">// 更新 MyPromise 的 value</span></span><br><span class="line">      <span class="keyword">this</span>.PromiseValue = reason;</span><br><span class="line">      <span class="comment">// 抛出错误信息</span></span><br><span class="line">      <span class="built_in">console</span>.error(reason);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 捕获，若 executor 报错，直接执行 reject</span></span><br><span class="line">    <span class="keyword">try</span>&#123;</span><br><span class="line">      executor(resolve, reject)</span><br><span class="line">    &#125;<span class="keyword">catch</span>(err) &#123;</span><br><span class="line">      reject(err)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// then 方法接受两个回调，onFulfilled 为成功时的回调，onRejected 为失败时的回调</span></span><br><span class="line">  then(onFulfilled, onRejected) &#123;</span><br><span class="line">    <span class="keyword">if</span>(<span class="keyword">this</span>.PromiseStatus==<span class="string">'resolved'</span>)&#123;</span><br><span class="line">      onFulfilled(<span class="keyword">this</span>.PromiseValue);</span><br><span class="line">    &#125; eslse <span class="keyword">if</span>(<span class="keyword">this</span>.PromiseStatus==<span class="string">'rejected'</span>) &#123;</span><br><span class="line">      onRejected(<span class="keyword">this</span>.PromiseValue);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="测试代码-1"><a href="#测试代码-1" class="headerlink" title="测试代码"></a>测试代码</h4><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">test</span>(<span class="params">arg</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> p = <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">if</span>(arg==<span class="string">'1'</span>) &#123;</span><br><span class="line">      resolve(<span class="string">'成功！'</span>)</span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">      reject(<span class="string">'失败！'</span>)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;)</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'test:'</span>, p);</span><br><span class="line">  p.then(<span class="function"><span class="params">value</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'then:'</span>, value)</span><br><span class="line">  &#125;).catch(<span class="function"><span class="params">reason</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'catch:'</span>, reason)</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> mp1 = <span class="keyword">new</span> MyPromise(<span class="function"><span class="params">()</span> =&gt;</span> &#123;&#125;)</span><br><span class="line"><span class="keyword">var</span> mp2 = <span class="keyword">new</span> MyPromise(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;resolve(<span class="number">123</span>)&#125;)</span><br><span class="line"><span class="keyword">var</span> mp3 = <span class="keyword">new</span> MyPromise(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;reject(<span class="number">123</span>)&#125;)</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(p1,mp1)</span><br><span class="line"><span class="built_in">console</span>.log(p2,mp2)</span><br><span class="line"><span class="built_in">console</span>.log(p3,mp3)</span><br></pre></td></tr></table></figure><h4 id="测试截图-1"><a href="#测试截图-1" class="headerlink" title="测试截图"></a>测试截图</h4><p>复制代码到控制台试试吧<del>~</del>  </p><p><img src="/images/write_promise1.png" alt="手写 Promise 1" title="手写 Promise 1"></p><p>更新中······</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&amp;emsp;&amp;emsp;Promise &lt;strong&gt;对象&lt;/strong&gt;用于表示一个&lt;strong&gt;异步操作&lt;/strong&gt;的最终完成 (或失败), 及其&lt;strong&gt;结果&lt;/strong&gt;值。&lt;a href=&quot;https://developer.mozilla.
      
    
    </summary>
    
      <category term="前端" scheme="http://huishanyi.club/categories/%E5%89%8D%E7%AB%AF/"/>
    
    
      <category term="ES6" scheme="http://huishanyi.club/tags/ES6/"/>
    
  </entry>
  
  <entry>
    <title>NodeJS面试题</title>
    <link href="http://huishanyi.club/2020/05/29/%E5%89%8D%E7%AB%AF%E9%9D%A2%E8%AF%95%E9%A2%98/NodeJS%E9%9D%A2%E8%AF%95%E9%A2%98/"/>
    <id>http://huishanyi.club/2020/05/29/前端面试题/NodeJS面试题/</id>
    <published>2020-05-28T23:52:56.000Z</published>
    <updated>2020-07-07T21:45:28.630Z</updated>
    
    <content type="html"><![CDATA[<p>&emsp;&emsp;本片文章将会每周不定期更新不定数量面试题，毕竟质量才是关键。<br>&emsp;&emsp;实践是检验真理的唯一标准！看题不记题，看题要做题！<br>&emsp;&emsp;面试是一个学习交流的过程，抱着虚心求教的心，人无完人，祝你变得更优秀！</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&amp;emsp;&amp;emsp;本片文章将会每周不定期更新不定数量面试题，毕竟质量才是关键。&lt;br&gt;&amp;emsp;&amp;emsp;实践是检验真理的唯一标准！看题不记题，看题要做题！&lt;br&gt;&amp;emsp;&amp;emsp;面试是一个学习交流的过程，抱着虚心求教的心，人无完人，祝你变得更优秀！&lt;/p
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>Vue面试题</title>
    <link href="http://huishanyi.club/2020/05/29/%E5%89%8D%E7%AB%AF%E9%9D%A2%E8%AF%95%E9%A2%98/Vue%E9%9D%A2%E8%AF%95%E9%A2%98/"/>
    <id>http://huishanyi.club/2020/05/29/前端面试题/Vue面试题/</id>
    <published>2020-05-28T23:52:28.000Z</published>
    <updated>2020-07-19T00:24:23.248Z</updated>
    
    <content type="html"><![CDATA[<p>&emsp;&emsp;本片文章将会每周不定期更新不定数量面试题，毕竟质量才是关键。<br>&emsp;&emsp;实践是检验真理的唯一标准！看题不记题，看题要做题！<br>&emsp;&emsp;面试是一个学习交流的过程，抱着虚心求教的心，人无完人，祝你变得更优秀！</p><h2 id="1-Vue-中-Key-的理解"><a href="#1-Vue-中-Key-的理解" class="headerlink" title="1. Vue 中 Key 的理解"></a>1. Vue 中 Key 的理解</h2><p><strong>作用</strong></p><ul><li>key 是虚拟 DOM 中的唯一标识<ul><li>使 Diff 算法更快的找到对应的节点，从而提高 Diff 的运行效率<ul><li>Vue 存在<code>就地更新</code>策略，默认是高效的，当该策略不产生副作用时，建议不要使用 key，这样可以取得更好的性能【只适用于不依赖子组件状态或临时 DOM 状态 (例如：表单输入值) 的列表渲染输出。】</li><li>有相同父元素的子元素必须有独特的 key</li></ul></li><li>保证相同标签名元素的过度切换（使 Vue 可以区分，否则只会替换其内部属性而不会触发过渡效果）</li></ul></li></ul><p><strong>场景</strong></p><ul><li><p>完整地触发组件的生命周期钩子</p><ul><li><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- text 变化就会重新渲染，diff 依靠 key 识别是否为新元素 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">transition</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">span</span> <span class="attr">:key</span>=<span class="string">"text"</span>&gt;</span>&#123;&#123; text &#125;&#125;<span class="tag">&lt;/<span class="name">span</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">transition</span>&gt;</span></span><br></pre></td></tr></table></figure></li></ul></li><li><p>触发过渡效果</p></li></ul><p><strong>原理</strong></p><ul><li>采用 Diff 算法<ul><li>通过 patchVnode 方法对比新旧 vnode（深度优先，同层比较）</li><li>通过 updateChildren 方法更新（首尾交叉对比）</li></ul></li></ul><p><strong>分析方法</strong></p><ul><li>下载源码</li><li>写个小例子打断点找到源码位置（比如写个列表）</li><li>源码位置：<code>src/core/vdompatch.js</code><ul><li>patchVnode 函数（Diff 发生的地方）</li><li>updateChildren 函数</li></ul></li></ul><h2 id="2-Vue-中-Diff-算法的理解"><a href="#2-Vue-中-Diff-算法的理解" class="headerlink" title="2. Vue 中 Diff 算法的理解"></a>2. Vue 中 Diff 算法的理解</h2><p><strong>作用</strong></p><ul><li>Diff 算法是为虚拟 DOM 的框架而生的，可以精确定位所改变的元素使组件更新更加准确与快速</li><li>源码 mountComponent 函数中，可以看出每挂载一个组件就会产生一个新  Watcher，为了保证 Vue 组件更新的准确性，采用 Diff 也就可以理解了</li><li>Diff 算法比较方式：深度优先，同层比较</li><li>触发时机：数据响应式触发 setter =&gt; setter 会触发通知 =&gt; 通知的方式就是将 watcher 添加到异步更新队列 =&gt; 事件循环结束则清空队列（watcher 执行他们的更新函数） =&gt; 更新函数执行时调用组件渲染函数和组件的更新函数 =&gt; 重新渲染最新的 VDom =&gt; 组件实例执行更新函数</li><li>打补丁：新旧 VDom 对比就叫做 patch</li></ul><p><strong>分析方法</strong></p><ul><li>源码位置：<code>src/instance/lifecycle.js</code><ul><li>mountComponent 函数<ul><li>每个组件都有一个 watcher，为了精确的更新，Diff 算法就很有必要了</li></ul></li></ul></li><li>源码位置：<code>src/core/vdompatch.js</code><ul><li>patchVnode 函数（深度优先，同层比较，Diff 发生的地方，源码见1）</li><li>updateChildren 函数（首位交叉对比，算法核心，源码见1）</li></ul></li></ul><h2 id="3-MVC、MVP、MVVM-的理解"><a href="#3-MVC、MVP、MVVM-的理解" class="headerlink" title="3. MVC、MVP、MVVM 的理解"></a>3. MVC、MVP、MVVM 的理解</h2><p>共同点：解决代码杂糅问题。<br>区别：MVP 是 MVC2.0，MVVM 是 MVC3.0。</p><ul><li>Web 1.0 时代<ul><li>早期开发，前后端未分离。虽然开发快，但代码较混乱（jsp，php，.net）。业务逻辑越复杂，单文件代码量越大，项目越难维护；</li><li>MVC 的诞生就是解决这一些问题，将项目拆分成 Model、View 和 Controller 三大部分。<ul><li>Model：保存应用数据，与后端数据进行同步；</li><li>View：将 Model 中的数据可视化，用户可在此进行操作；</li><li>Controler：业务逻辑，根据用户操作修改 Model 中的数据。</li><li>MVC 刚诞生时仅用于后端，比如 spring、Structs 等框架，前端只是 View 部分（前端输出静态页面交给后端，后端人员使用模板语法做整合）。</li><li>优点<ul><li>低耦合</li><li>可复用</li><li>易维护</li></ul></li><li>缺点<ul><li>增加系统结构，实现较复杂，需要考虑代码功能划分，最好用于大点的项目，否则得不偿失；</li><li>View 与 Controller 联系过于紧密。拆分不够完全，很难独立复用；</li><li>View 对 Model 的低效率访问。Model 中接口不同，View 可能需要多次调用才能拿全数据；</li></ul></li></ul></li></ul></li><li>Web 2.0 时代<ul><li>Google 的 Gmail 出现，伴生的 ajax 可使前后台进行交互；</li><li>前后端分离，前端专注 HTML、CSS、JS，后端专注数据服务，协同开发，效率提高；</li><li>前端通过 ajax 拥有了使页面局部刷新的能力，减轻了后端的负载和流量消耗，用户体验更佳；</li><li>专职前端出现，页面内容越来越多，前端代码量变大，项目难维护。</li></ul></li><li>MVP 模式<ul><li>Model：提供数据；</li><li>View：负责显示；</li><li>Presenter：负责 Model 与 View 之间的通信；</li><li>MVC 衍变而来。</li><li>优点<ul><li>View 与 Model 完全隔离；</li><li>Presenter 与 View 具体实现技术无关。</li></ul></li><li>缺点<ul><li>增加了代码复杂度</li><li>Presenter 中除了有 Controller 代码，还有大量 Model 与 View 的手动同步逻辑代码，难维护；</li><li>Presenter 与 View 的耦合度较高。</li></ul></li></ul></li><li>Web 3.0 时代<ul><li>前端 MVC 模式出现（将后端 MVC 中的 V 拆为前端的 MVC）；</li><li>前端 MVVM 模式出现（Angular、React、Vue）。<ul><li>Model-View-ViewModel</li><li>优点<ul><li>低耦合</li><li>可重用</li><li>独立开发</li><li>可测试（测试 viewModel）</li></ul></li></ul></li></ul></li></ul><h2 id="4-Vue-设计原则（理念）"><a href="#4-Vue-设计原则（理念）" class="headerlink" title="4. Vue 设计原则（理念）"></a>4. Vue 设计原则（理念）</h2><ul><li>渐进式 JavaScript 框架；<ul><li>自底向上逐层应用（有着足够庞大的生态去应对多种需求，无论是简单的静态页，还是需要路由跳转，更或者全局状态管理都可以满足）；</li><li>核心库（DeclarativeRendering、ComponsentSystem）只关注视图层。</li></ul></li><li>易用：没有学习过 Vue，只要你是前端，看着开发文档就可以上手，学习曲线很平滑，模板语法太友善了；</li><li>灵活：渐进式，可以是构建用户界面的 JavaScript 库，也可以是一套完整的框架；</li><li>高效：Vue2 引入了虚拟 DOM 和 Diff 算法，Vue3 引入 Proxy 对数据响应式改进。</li></ul><h2 id="5-Vue-组件化的理解"><a href="#5-Vue-组件化的理解" class="headerlink" title="5. Vue 组件化的理解"></a>5. Vue 组件化的理解</h2><p><strong>定义</strong></p><ul><li>将复杂系统解耦，拆分成多个功能模块，并根据业务进行重组复用；</li><li>组件化其实就是一个做积木搭积木的过程；</li><li>Vue 的核心特性之一。</li></ul><p><strong>使用场景</strong><br>页面元素多样，业务逻辑复杂，功能模块可拆分。</p><p><strong>优点</strong></p><ul><li>功能复用，协同开发，提高开发效率；</li><li>单元测试；</li><li>可针对指定组件进行更新，提高性能(<code>lifecycle.js - mountComponent()</code>，一个组件一个 watcher)；</li><li>扩展性高。</li></ul><p><strong>注意事项</strong></p><ul><li>组件应该是高内聚、低耦合的（任性复用）；</li><li>合理的拆分组件才能将组件化的优点最大化；</li><li>数据传递时尽量遵循单向数据流原则，避免关系混乱。</li></ul><p><strong>Vue 组件化特点</strong></p><ul><li>声明组件：Vue.component()；</li><li>单文件组件（vue-loader 将 template 编译成 render 函数）；</li><li>组件配置 =&gt; VDOM =&gt; DOM；（通过 <code>patch.js - createElm()</code> 实例化及挂载）</li><li>属性 prop；</li><li>自定义事件；</li><li>插槽；</li><li>双向数据绑定。</li></ul><h2 id="6-Vue-组件之间的通讯方式"><a href="#6-Vue-组件之间的通讯方式" class="headerlink" title="6. Vue 组件之间的通讯方式"></a>6. Vue 组件之间的通讯方式</h2><p><strong>父子组件</strong></p><ul><li>父组件向子组件传值<ul><li>props</li><li>ref（直接访问 DOM 元素）</li><li>$children（做封装后使用，避免依赖 DOM）</li></ul></li><li>子组件向父组件传值<ul><li>$emit / $on</li><li>$parent（做封装后使用，避免依赖 DOM）</li></ul></li></ul><p><strong>兄弟组件</strong></p><ul><li>$parent</li><li>$root</li><li>eventbus</li><li>vuex</li></ul><p><strong>跨层级关系</strong></p><ul><li>eventbus</li><li>$attrs / $listeners（在子组件中处理非属性值的传递）</li><li>provide/inject（单向，祖辈向后代传值）</li><li>vuex</li></ul><h2 id="7-Vue-组件模板只能有一个根元素"><a href="#7-Vue-组件模板只能有一个根元素" class="headerlink" title="7. Vue 组件模板只能有一个根元素"></a>7. Vue 组件模板只能有一个根元素</h2><ul><li>实例化 Vue 创建组件时，el 选项只能定一个根元素（入口）；</li><li>单文件组件为一个 Vue 实例，一个 Vue 实例只能定一个根元素；</li><li>Diff 算法比较时需要有相同的根。</li></ul><h2 id="8-Vue-组件中-data-选项必须为函数而根实例无此限制"><a href="#8-Vue-组件中-data-选项必须为函数而根实例无此限制" class="headerlink" title="8. Vue 组件中 data 选项必须为函数而根实例无此限制"></a>8. Vue 组件中 data 选项必须为函数而根实例无此限制</h2><ul><li>Vue 组件<ul><li>官网有说明<strong>当在组件中使用 data property 的时候 (除了 new Vue 外的任何地方)，它的值必须是返回一个对象的函数</strong>；</li><li>Vue 组件中的 data 不是函数时无法通过 Vue 检测，提示需要将 data 改为函数；</li><li>Vue 组件可能存在多个实例；<ul><li>以对象形式定义 data 会导致它们公用一个 data 从而产生数据污染；</li><li>以函数形式定义 data，由于函数的闭包特性，不会产生数据污染；</li></ul></li></ul></li><li>Vue 根实例<ul><li>根实例只有一个，不会产生数据污染，所以没限制，也不需要做这种限制。</li></ul></li></ul><h2 id="9-v-if-和-v-for-优先级"><a href="#9-v-if-和-v-for-优先级" class="headerlink" title="9. v-if 和 v-for 优先级"></a>9. v-if 和 v-for 优先级</h2><ul><li>官网有说明<code>v-for</code>比<code>v-if</code>具有更高的优先级；</li><li>写个<code>v-for</code>和<code>v-if</code>同级的情况，打印下<code>app.$options.render</code>，看下渲染函数；</li><li>源码<code>src/compiler/codegen/index.js</code> genElement() 函数中判断条件<code>for</code>是高于<code>if</code>的；</li><li>如果两个条件需要同时作用，可以先将<code>v-if</code>提到<code>v-for</code>的上层，减少每次循环都做判断导致的性能消耗；</li><li>如果<code>v-for</code>和<code>v-if</code>必须作用在一个标签上，那就应该考虑列表数组中数据的筛选了，<code>v-for</code>作用的应该是渲染数组（这么理解的话，就不会产生<code>v-for</code>和<code>v-if</code>必须作用在一个标签上的情况）。</li></ul><h2 id="10-vue-router-中保护指定路由的安全"><a href="#10-vue-router-中保护指定路由的安全" class="headerlink" title="10. vue-router 中保护指定路由的安全"></a>10. vue-router 中保护指定路由的安全</h2><p>通过导航守卫（钩子函数）在路由跳转时先判断条件（是否登录，是否有权限）再决定是否跳转</p><ul><li>全局守卫<ul><li>触发时机：全局有导航发生时</li><li>无法获取组件实例</li><li>全局前置守卫（beforeEach(to, from, next)）<ul><li>to：目标路由</li><li>from：当前路由</li><li>next：高阶函数，处理传过来的参数，返回一个设置的 hook 来决定导航后续该怎么做<ul><li>不传参：正常放行</li><li>传参<ul><li>next(false)：未登录、无权限时阻止导航</li><li>next(path)：传递 path 字符串可以重定向到一个新地址</li></ul></li></ul></li></ul></li><li>全局解析守卫（beforeResolve(to, from, next)）</li><li>全局后置钩子（afterEach(to, from)）</li></ul></li><li>路由独享守卫（beforeEnter(to, from, next)）<ul><li>触发时机：发生与当前路由相关的导航时</li><li>无法获取组件实例</li></ul></li><li>组件内的守卫<ul><li>触发时机：用到当前组件时</li><li>可以获取组件实例</li><li>beforeRouteEnter(to, from, next)<ul><li>导航确认前调用</li><li>不能获取组件实例 <code>this</code></li><li>组件实例还没被创建</li></ul></li><li>beforeRouteUpdate(to, from, next)<ul><li>导航更新时调用（例如：复用组件时，路径由<code>test/01</code>跳转至<code>test/02</code>时，就会调用此函数）</li></ul></li><li>beforeRouteLeave(to, from, next)<ul><li>导航离开前调用（例如：填完表单还未保存就离开，执行此函数让用户进行确认是否离开）</li></ul></li></ul></li></ul><p>导航解析流程：</p><ol><li>导航被触发。</li><li>在失活的组件里调用 beforeRouteLeave 守卫。</li><li>调用全局的 beforeEach 守卫。</li><li>在重用的组件里调用 beforeRouteUpdate 守卫 (2.2+)。</li><li>在路由配置里调用 beforeEnter。</li><li>解析异步路由组件。</li><li>在被激活的组件里调用 beforeRouteEnter。</li><li>调用全局的 beforeResolve 守卫 (2.5+)。</li><li>导航被确认。</li><li>调用全局的 afterEach 钩子。</li><li>触发 DOM 更新。</li><li>用创建好的实例调用 beforeRouteEnter 守卫中传给 next 的回调函数。</li></ol><h2 id="11-nextTick-的理解"><a href="#11-nextTick-的理解" class="headerlink" title="11. nextTick 的理解"></a>11. nextTick 的理解</h2><p><strong>定义</strong><br>nextTick 是 Vue 的一个全局 API，由于 Vue 的异步更新策略导致我们对数据的直接修改不会立刻体现在 DOM 中，在这种情况下使用 nextTick 方法即可解决。</p><p><strong>作用</strong><br>由于 Vue 在更新 DOM 时是异步执行。只要侦听到数据变化，Vue 将开启一个队列，并缓冲在同一事件循环中发生的所有数据变更。如果同一个 watcher 被多次触发，只会被推入到队列一次。这种在缓冲时去除重复数据对于避免不必要的计算和 DOM 操作是非常重要的。nextTick 方法会在队列中加入一个回调函数，确保函数在前面的 DOM 操作完成后调用。</p><p><strong>使用方法</strong></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">&lt;div id=<span class="string">"example"</span>&gt;&#123;&#123;message&#125;&#125;&lt;<span class="regexp">/div&gt;</span></span><br><span class="line"><span class="regexp">var vm = new Vue(&#123;</span></span><br><span class="line"><span class="regexp">  el: '#example',</span></span><br><span class="line"><span class="regexp">  data: &#123;</span></span><br><span class="line"><span class="regexp">    message: '123'</span></span><br><span class="line"><span class="regexp">  &#125;</span></span><br><span class="line"><span class="regexp">&#125;)</span></span><br><span class="line"><span class="regexp">vm.message = 'new message' /</span><span class="regexp">/ 更改数据</span></span><br><span class="line"><span class="regexp">vm.$el.textContent === 'new message' /</span><span class="regexp">/ DOM 未更新</span></span><br><span class="line"><span class="regexp">Vue.nextTick(function () &#123;</span></span><br><span class="line"><span class="regexp">  vm.$el.textContent === 'new message' /</span><span class="regexp">/ DOM 更新</span></span><br><span class="line"><span class="regexp">&#125;)</span></span><br><span class="line"><span class="regexp"></span></span><br><span class="line"><span class="regexp">/</span>*********************************************************<span class="regexp">/</span></span><br><span class="line"><span class="regexp"></span></span><br><span class="line"><span class="regexp">/</span><span class="regexp">/ 组件内使用</span></span><br><span class="line"><span class="regexp">Vue.component('example', &#123;</span></span><br><span class="line"><span class="regexp">  template: '&lt;span&gt;&#123;&#123; message &#125;&#125;&lt;/</span>span&gt;<span class="string">',</span></span><br><span class="line"><span class="string">  data: function () &#123;</span></span><br><span class="line"><span class="string">    return &#123;</span></span><br><span class="line"><span class="string">      message: '</span>未更新<span class="string">'</span></span><br><span class="line"><span class="string">    &#125;</span></span><br><span class="line"><span class="string">  &#125;,</span></span><br><span class="line"><span class="string">  methods: &#123;</span></span><br><span class="line"><span class="string">    updateMessage: function () &#123;</span></span><br><span class="line"><span class="string">      this.message = '</span>已更新<span class="string">'</span></span><br><span class="line"><span class="string">      console.log(this.$el.textContent) // 未更新</span></span><br><span class="line"><span class="string">      this.$nextTick(function () &#123;</span></span><br><span class="line"><span class="string">        console.log(this.$el.textContent) // 已更新</span></span><br><span class="line"><span class="string">      &#125;)</span></span><br><span class="line"><span class="string">    &#125;</span></span><br><span class="line"><span class="string">  &#125;</span></span><br><span class="line"><span class="string">&#125;)</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">/********************************************************/</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">// 作为一个 Promise 使用 (2.1.0 起新增)</span></span><br><span class="line"><span class="string">Vue.nextTick()</span></span><br><span class="line"><span class="string">  .then(function () &#123;</span></span><br><span class="line"><span class="string">    // DOM 更新了</span></span><br><span class="line"><span class="string">  &#125;)</span></span><br></pre></td></tr></table></figure><p><strong>原理</strong><br>将我们传入 nextTick 中的函数加入到 callbacks 里，然后使用 timerFunc 函数异步调用，Vue 在内部对异步队列尝试使用原生的 Promise.then、MutationObserver 和 setImmediate，如果执行环境不支持，则会采用 setTimeout(fn, 0) 代替。</p><h2 id="12-Vue-的响应式"><a href="#12-Vue-的响应式" class="headerlink" title="12. Vue 的响应式"></a>12. Vue 的响应式</h2><p><strong>定义</strong><br>监听数据变化（更改数据） 并 作出响应（更新 DOM）。</p><p><strong>作用</strong><br>MVVM 框架中解决的一个核心问题就是连接数据层和视图层，通过数据驱动应用，数据变化，视图更新，数据响应式处理就是为了解决这个问题。</p><p><strong>原理</strong></p><p><strong>优缺点</strong></p><ul><li>优点<ul><li>只操作数据，不用频繁的操作 DOM，既降低了开发难度，又提升了开发效率（Diff 算法）</li></ul></li><li>缺点<ul><li>初始化时递归遍历会造成性能损失</li></ul></li></ul><p><strong>Vue3 中响应式的新变化</strong></p><h2 id="13-Vue-性能优化"><a href="#13-Vue-性能优化" class="headerlink" title="13. Vue 性能优化"></a>13. Vue 性能优化</h2><p><strong>路由懒加载</strong></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> router = <span class="keyword">new</span> VueRouter(&#123;</span><br><span class="line">    routes: [</span><br><span class="line">        &#123;<span class="attr">path</span>:<span class="string">'/foo'</span>, <span class="attr">component</span>: <span class="function"><span class="params">()</span> =&gt;</span> <span class="keyword">import</span>(<span class="string">'.Foo.vue'</span>)&#125;</span><br><span class="line">    ]</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p><strong>keep-alive缓存页面</strong></p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">template</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">"app"</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">keep-alive</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">router-view</span> /&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">keep-live</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">template</span>&gt;</span></span><br></pre></td></tr></table></figure><p><strong>合理的利用v-show替换v-if</strong><br>v-show 的原理是使用 display 属性实现的隐藏显示，v-if 的原理是删除创建，所以你懂得<del>~</del></p><p><strong>v-for与v-if同级时</strong><br>官方文档建议在同时需要使用 v-for 和 v-if 时，把 v-if 提到外层，避免每次循环都进行条件判断，但是有时业务逻辑就需要你在循环项做判断，我们可以使用 computed 对需遍历数组先过滤一遍。</p><p><strong>长列表做虚拟滚动</strong><br>使用 vue-virtual-scroller 对长列表进行区域渲染(DOM 复用，只对内容进行更新)。</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">recycle-scroller</span></span></span><br><span class="line"><span class="tag">    <span class="attr">class</span>=<span class="string">"items"</span></span></span><br><span class="line"><span class="tag">    <span class="attr">:items</span>=<span class="string">"items"</span></span></span><br><span class="line"><span class="tag">    <span class="attr">:item-size</span>=<span class="string">"24"</span></span></span><br><span class="line"><span class="tag">&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">template</span> <span class="attr">v-slot</span>=<span class="string">"&#123;items&#125;"</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">FetchItemView</span></span></span><br><span class="line"><span class="tag">            <span class="attr">:item</span>=<span class="string">"item"</span></span></span><br><span class="line"><span class="tag">            @<span class="attr">vote</span>=<span class="string">"voteItem(item)"</span></span></span><br><span class="line"><span class="tag">        /&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">template</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">recycle-scroller</span>&gt;</span></span><br></pre></td></tr></table></figure><p><strong>订阅后要在组件销毁时取消订阅</strong><br>Vue 组件销毁时，会自动解绑它的全部指令及事件监听器，但是仅限于组件本身的事件。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">created() &#123;</span><br><span class="line">    <span class="keyword">this</span>.timer = setInterval(<span class="keyword">this</span>.refresh, <span class="number">2000</span>)</span><br><span class="line">&#125;,</span><br><span class="line">beforeDestroy() &#123;</span><br><span class="line">    <span class="comment">// 取消订阅防止内存泄漏</span></span><br><span class="line">    clearInterval(<span class="keyword">this</span>.timer)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>图片懒加载</strong><br>图片过多时，使用 vue-lazyload 仅加载当前可视区域的图片。</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">img</span> <span class="attr">v-lazy</span>=<span class="string">"/static/img/1.png"</span> /&gt;</span></span><br></pre></td></tr></table></figure><p><strong>第三方库做按需引入策略</strong><br>项目开发中仅依赖第三方库中的部分组件或方法，按需引入避免体积过大。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; Button, Select &#125; <span class="keyword">from</span> <span class="string">'element-ui'</span></span><br></pre></td></tr></table></figure><p><strong>无状态组件标记为函数时组件</strong></p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">template</span> <span class="attr">functional</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"cell"</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">div</span> <span class="attr">v-if</span>=<span class="string">"props.value"</span> <span class="attr">class</span>=<span class="string">"on"</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">section</span> <span class="attr">v-else</span> <span class="attr">class</span>=<span class="string">"off"</span>&gt;</span><span class="tag">&lt;/<span class="name">section</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">template</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="javascript">    <span class="keyword">export</span> <span class="keyword">default</span> &#123;</span></span><br><span class="line"><span class="javascript">        props: [<span class="string">'value'</span>]</span></span><br><span class="line">    &#125;</span><br><span class="line"><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure><p><strong>子组件分割</strong><br>对组件内部渲染频繁的部分进行拆分，使其单独管理自身渲染，减少不必要的渲染。</p><p><strong>变量本地化</strong><br>频繁调用的数据存储为变量，减少引用次数。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> a = <span class="keyword">this</span>.a;</span><br><span class="line"><span class="keyword">let</span> b;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> i=<span class="number">0</span>; i&lt;<span class="number">1000</span>; i++) &#123;</span><br><span class="line">    b = b + a</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> b;</span><br></pre></td></tr></table></figure><h2 id="14-Vue3-新特性"><a href="#14-Vue3-新特性" class="headerlink" title="14. Vue3 新特性"></a>14. Vue3 新特性</h2><ul><li>更快<ul><li>虚拟 DOM 重写<ul><li>组件快速路径（Component fast path）</li><li>单个调用（Monomorphic calls）</li><li>子节点类型检测（Children type detection）</li></ul></li><li>优化 slots 生成</li><li>静态树提升</li><li>静态属性提升</li><li>基于 Proxy 的响应式系统</li></ul></li><li>更小<ul><li>通过摇树优化核心库体积</li></ul></li><li>更易维护<ul><li>TypeScript + 模块化</li></ul></li><li>更加友好<ul><li>跨平台：编译器核心和运行时核心与平台无关，使 Vue 更容易在多平台使用</li></ul></li><li>更易使用<ul><li>改进对 TypeScript 的支持，编辑器可以提供更明确地类型检查和错误警告</li><li>更好的调试支持</li><li>独立的响应化模块</li><li>Composition API</li></ul></li></ul><p>理解才能更好的使用！</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&amp;emsp;&amp;emsp;本片文章将会每周不定期更新不定数量面试题，毕竟质量才是关键。&lt;br&gt;&amp;emsp;&amp;emsp;实践是检验真理的唯一标准！看题不记题，看题要做题！&lt;br&gt;&amp;emsp;&amp;emsp;面试是一个学习交流的过程，抱着虚心求教的心，人无完人，祝你变得更优秀！&lt;/p
      
    
    </summary>
    
      <category term="前端" scheme="http://huishanyi.club/categories/%E5%89%8D%E7%AB%AF/"/>
    
    
      <category term="前端面试题" scheme="http://huishanyi.club/tags/%E5%89%8D%E7%AB%AF%E9%9D%A2%E8%AF%95%E9%A2%98/"/>
    
  </entry>
  
  <entry>
    <title>React面试题</title>
    <link href="http://huishanyi.club/2020/05/29/%E5%89%8D%E7%AB%AF%E9%9D%A2%E8%AF%95%E9%A2%98/React%E9%9D%A2%E8%AF%95%E9%A2%98/"/>
    <id>http://huishanyi.club/2020/05/29/前端面试题/React面试题/</id>
    <published>2020-05-28T23:52:13.000Z</published>
    <updated>2020-08-24T00:15:43.722Z</updated>
    
    <content type="html"><![CDATA[<p>&emsp;&emsp;本片文章将会每周不定期更新不定数量面试题，毕竟质量才是关键。<br>&emsp;&emsp;实践是检验真理的唯一标准！看题不记题，看题要做题！<br>&emsp;&emsp;面试是一个学习交流的过程，抱着虚心求教的心，人无完人，祝你变得更优秀！</p><h2 id="React-中对-key-的理解"><a href="#React-中对-key-的理解" class="headerlink" title="React 中对 key 的理解"></a>React 中对 key 的理解</h2><p><strong>作用</strong>  </p><ul><li>key 是虚拟 DOM 中的唯一标识<ul><li>Diff 算法可以更快的找到对应的新旧元素节点，从而提高 Diff 运算效率；</li><li>key 值保证了元素渲染后的更新效果；</li><li>遍历的元素没有 key 属性会报警告。</li></ul></li></ul><p><strong>场景</strong>  </p><ul><li>遍历的元素就要用 key</li></ul><p><strong>原理</strong>  </p><ul><li>采用 Diff 算法</li></ul><p><strong>注意</strong>  </p><ul><li>key 是唯一标识，切记不要使用遍历的 index 值<ul><li>使用 index 作为 key 会导致额外的性能消耗；</li><li>使用 index 作为 key 会导致渲染出错。</li></ul></li><li>React 要求遍历元素必须使用 key，但不使用没有报 error 而是 warning<ul><li>React 默认（子组件无状态变化，为定值，不存在动态值如 input 输入框）为无 key 的遍历元素加 key，值为 index。</li></ul></li><li>key 的唯一性是存在与兄弟（React 不存在表兄弟，堂兄弟）元素间<ul><li>举个例子：老王有 3 个娃（小明，小红，小黑），老李也有 3 个娃（小明，小红，小黑），但是他俩的 3 个娃不需要标记（姓就不同）。</li></ul></li><li>key 不能是随机数（key 应唯一且稳定，无论遍历几次 key 都不会变）<ul><li>举个例子：老王带着 3 个娃（小明，小红，小黑）报班，报成功了，第二天送娃（娃改名字了，小亮、小赤、小暗）去上课，补课班（React）报班人太多，记不清孩子样子，只认登记的名字，很尴尬老王又报了一次名，多浪费了一次钱（额外的性能消耗）。</li></ul></li></ul><h2 id="React-中-Diff-算法的理解"><a href="#React-中-Diff-算法的理解" class="headerlink" title="React 中 Diff 算法的理解"></a>React 中 Diff 算法的理解</h2><p>详细请看 <a href="/2019/09/23/React/React虚拟DOM/" target="_blank">React虚拟DOM</a>。</p><ul><li>Diff 算法为虚拟 DOM 而生，可以更快的找到对应的新旧元素节点，从而提高 Diff 运算效率；</li><li>Diff 算法比较方式：深度优先，同层比较；</li><li>React 中的 Diff 算法基于两个假设<ol><li>两个不同类型的元素会产生出不同的树；</li><li>开发者可以通过 key 属性来暗示哪些子元素在不同的渲染下能保持稳定；</li></ol></li></ul><p><strong>分析方法</strong></p><ul><li>_updateChildren() 方法</li></ul><h2 id="React-生命周期的理解"><a href="#React-生命周期的理解" class="headerlink" title="React 生命周期的理解"></a>React 生命周期的理解</h2><p>详细请看 <a href="/2019/11/18/React/React生命周期/" target="_blank">React生命周期</a>。</p><ul><li>React 15<ul><li>constructor()：初始化 props 和 state<ul><li>super(props) 获取来自父组件传来的参数</li><li>this.state 初始状态</li></ul></li><li>componentWillMount()：组件将进行渲染钩子</li><li>render()：组件渲染钩子</li><li>componentDidMount()：组件渲染完成钩子，此处进行数据请求</li><li>componentWillReceiveProps()：组件将接收参数钩子，props 改变引起的组件更新</li><li>shouldComponentUpdate(nextProps，nextState)：组件是否应该更新钩子，可以在此处对比前后的 state 与 props，来判断是否更新组件，做性能优化</li><li>componentDidUpdate(prevProps, prevState)：组件更新完成钩子</li><li>componentWillUnmount()：组件即将卸载钩子，在此处进行取消订阅，避免内存泄漏</li></ul></li><li>React 16.4<ul><li>constructor()：初始化 props 和 state<ul><li>super(props) 获取来自父组件传来的参数</li><li>this.state 初始状态</li></ul></li><li>render()：组件渲染钩子</li><li>componentDidMount()：组件渲染完成钩子，此处进行数据请求</li><li>static getDerivedStateFromProps()：从 props 中获取 state，贯穿 constructor 与 shouldComponentUpdate 之间，必须用 static 生命，否则会被忽略</li><li>shouldComponentUpdate(nextProps，nextState)：组件是否应该更新钩子，可以在此处对比前后的 state 与 props，来判断是否更新组件，做性能优化</li><li>getSnapshotBeforeUpdate(prevProps, prevState)：更新前获取快照，在最近一次渲染输出（提交到 DOM 节点）之前调用，并返回 null 或者 snapshort（snapshort 会传递给 componentDidUpdate()）</li><li>componentDidUpdate(prevProps, prevState, snapshot)：组件更新完成钩子，snapshot 为 getSnapshotBeforeUpdate() 传递而来</li><li>componentWillUnmount()：组件即将卸载钩子，在此处进行取消订阅，避免内存泄漏</li></ul></li><li>React 16.8+（Hook）<ul><li>useState()：初始化 state，代替 constructor 中的 this.state</li><li>render()：组件渲染钩子</li><li>useEffect()：代替 componentDidMount, componentDidUpdate, componentWillUnmount，由此可见该方法时发生在渲染后</li><li>useMemo()：代替 shouldComponentUpdate()，使用备忘录，记忆组件之前的状态，当更新时该组件状态不变，则跳过本次渲染</li><li>useLayoutEffect()：useEffect 出错时使用，发生于渲染前，毕竟布局是要在渲染前开始的</li></ul></li></ul><h2 id="React-refs-的理解"><a href="#React-refs-的理解" class="headerlink" title="React refs 的理解"></a>React refs 的理解</h2><h2 id="React-事件系统的理解"><a href="#React-事件系统的理解" class="headerlink" title="React 事件系统的理解"></a>React 事件系统的理解</h2><h2 id="setState-的理解"><a href="#setState-的理解" class="headerlink" title="setState 的理解"></a>setState 的理解</h2><h2 id="React-的组件通信方式"><a href="#React-的组件通信方式" class="headerlink" title="React 的组件通信方式"></a>React 的组件通信方式</h2><h2 id="谈谈对函数组件与-class-组件的理解"><a href="#谈谈对函数组件与-class-组件的理解" class="headerlink" title="谈谈对函数组件与 class 组件的理解"></a>谈谈对函数组件与 class 组件的理解</h2><h2 id="React-性能优化方案"><a href="#React-性能优化方案" class="headerlink" title="React 性能优化方案"></a>React 性能优化方案</h2>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&amp;emsp;&amp;emsp;本片文章将会每周不定期更新不定数量面试题，毕竟质量才是关键。&lt;br&gt;&amp;emsp;&amp;emsp;实践是检验真理的唯一标准！看题不记题，看题要做题！&lt;br&gt;&amp;emsp;&amp;emsp;面试是一个学习交流的过程，抱着虚心求教的心，人无完人，祝你变得更优秀！&lt;/p
      
    
    </summary>
    
      <category term="前端" scheme="http://huishanyi.club/categories/%E5%89%8D%E7%AB%AF/"/>
    
    
      <category term="前端面试题" scheme="http://huishanyi.club/tags/%E5%89%8D%E7%AB%AF%E9%9D%A2%E8%AF%95%E9%A2%98/"/>
    
  </entry>
  
  <entry>
    <title>CSS面试题</title>
    <link href="http://huishanyi.club/2020/05/29/%E5%89%8D%E7%AB%AF%E9%9D%A2%E8%AF%95%E9%A2%98/CSS%E9%9D%A2%E8%AF%95%E9%A2%98/"/>
    <id>http://huishanyi.club/2020/05/29/前端面试题/CSS面试题/</id>
    <published>2020-05-28T23:51:59.000Z</published>
    <updated>2020-07-07T21:45:28.629Z</updated>
    
    <content type="html"><![CDATA[<p>&emsp;&emsp;本片文章将会每周不定期更新不定数量面试题，毕竟质量才是关键。<br>&emsp;&emsp;实践是检验真理的唯一标准！看题不记题，看题要做题！<br>&emsp;&emsp;面试是一个学习交流的过程，抱着虚心求教的心，人无完人，祝你变得更优秀！</p><h2 id="谈谈标准盒模型和怪异盒模型"><a href="#谈谈标准盒模型和怪异盒模型" class="headerlink" title="谈谈标准盒模型和怪异盒模型"></a>谈谈标准盒模型和怪异盒模型</h2><ul><li>标准盒模型<ul><li>width = contentWidth</li></ul></li><li>怪异盒模型（IE 盒模型）<ul><li>width = contentWidth + padding + border</li></ul></li></ul><h2 id="两栏布局"><a href="#两栏布局" class="headerlink" title="两栏布局"></a>两栏布局</h2><ul><li><p>float + margin</p><ul><li>html<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">style</span>&gt;</span></span><br><span class="line">    .left &#123;</span><br><span class="line">        width: 200px;</span><br><span class="line">        height: 100vh;</span><br><span class="line">        float: left;</span><br><span class="line">    &#125;</span><br><span class="line">    .right &#123;</span><br><span class="line">        width: 100%;</span><br><span class="line">        height: 100vh;</span><br><span class="line">        margin-left: 200px;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="tag">&lt;/<span class="name">style</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"left"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"right"</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br></pre></td></tr></table></figure></li></ul></li><li><p>position</p></li><li><p>flex（不推荐，兼容性较差）</p></li><li><p>inline-block + calc（不推荐，兼容性较差）</p></li></ul><h2 id="三栏布局"><a href="#三栏布局" class="headerlink" title="三栏布局"></a>三栏布局</h2><ul><li><p>float + margin（<strong>中间元素移动要放到最后，否则右元素会被挤到下一行</strong>）</p><ul><li>html<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">style</span>&gt;</span></span><br><span class="line">    .left &#123;</span><br><span class="line">        float: left;</span><br><span class="line">        width: 200px;</span><br><span class="line">    &#125;</span><br><span class="line">    .center &#123;</span><br><span class="line">        margin: 0 100px 0 200px;</span><br><span class="line">    &#125;</span><br><span class="line">    .right &#123;</span><br><span class="line">        float: right;</span><br><span class="line">        width: 100px;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="tag">&lt;/<span class="name">style</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"left"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"right"</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- 中间元素移动要放到最后，否则 right 元素会被挤到下一行 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"center"</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br></pre></td></tr></table></figure></li></ul></li><li><p>position</p></li><li><p>flex（不推荐，兼容性较差）</p></li><li><p>inline-block + calc（不推荐，兼容性较差）</p></li></ul><h2 id="水平居中方案"><a href="#水平居中方案" class="headerlink" title="水平居中方案"></a>水平居中方案</h2><ul><li>行内元素（inline）<ul><li>给父级加<code>text-align: center;</code></li><li>给一个左右相等的 margin（宽度为内容撑开，无背景色情况下 padding 也可以做到）</li><li>定位(根据应用场景选取 absolute 或者 fixed，left 与 right 置 0，margin 水平值给 auto)</li></ul></li><li>块元素（block）<ul><li>给一个左右相等的 margin（宽度为内容撑开，无背景色情况下 padding 也可以做到）</li><li>定宽（定位，可根据应用场景选取 relative 、 absolute 或者 fixed）<ul><li>left 与 right 置 0，margin 水平值给 auto</li><li>left 给 50%，margin-left 给宽度的一半</li><li>left 设置为 <code>calc(50% - 宽度的一半)</code></li></ul></li><li>宽度自适应<ul><li>width 设置为 fit-content，margin 水平值给 auto</li><li>定位，left 给 50%，<code>transform: translateX(-50%)</code></li></ul></li></ul></li><li>行内块元素（inline-block）<ul><li>给父级加<code>text-align: center;</code></li><li>给一个左右相等的 margin（宽度为内容撑开，无背景色情况下 padding 也可以做到）</li><li>定宽（定位，可根据应用场景选取 relative 、 absolute 或者 fixed）<ul><li>left 与 right 置 0，margin 水平值给 auto</li><li>left 给 50%，margin-left 给宽度的一半</li><li>left 设置为 <code>calc(50% - 宽度的一半)</code></li></ul></li><li>宽度自适应<ul><li>width 设置为 fit-content，margin 水平值给 auto</li><li>定位，left 给 50%，<code>transform: translateX(-50%)</code></li></ul></li></ul></li><li>弹性盒子（flex）<ul><li>父级设置<code>justify-content: center;</code></li></ul></li></ul><h2 id="垂直居中方案"><a href="#垂直居中方案" class="headerlink" title="垂直居中方案"></a>垂直居中方案</h2><ul><li>行内元素（inline）<ul><li>给父级加 line-height 并且值等于 height</li></ul></li><li>块元素（block）<ul><li>给一个上下相等的 margin（高度为内容撑开，无背景色情况下 padding 也可以做到）</li><li>定位(根据应用场景选取 relative 、 absolute 或者 fixed)<ul><li>定高<ul><li>top 与 bottom 置 0，margin 纵向值给 auto</li><li>top 设置为 <code>calc(50% - 高度的一半)</code></li></ul></li><li>高度自适应<ul><li>top 给 50%，<code>transform: translateY(-50%)</code></li></ul></li></ul></li></ul></li><li>行内块元素（inline-block）<ul><li>给父级加 line-height 并且值等于 height</li><li>给一个上下相等的 margin（高度为内容撑开，无背景色情况下 padding 也可以做到）</li><li>定位(根据应用场景选取 relative 、 absolute 或者 fixed)<ul><li>定高<ul><li>top 与 bottom 置 0，margin 纵向值给 auto</li><li>top 设置为 <code>calc(50% - 高度的一半)</code></li></ul></li><li>高度自适应<ul><li>top 给 50%，<code>transform: translateY(-50%)</code></li></ul></li></ul></li></ul></li><li>弹性盒子（flex）<ul><li>父级设置<code>align-items: center;</code></li></ul></li></ul><h2 id="清除浮动副作用的方法"><a href="#清除浮动副作用的方法" class="headerlink" title="清除浮动副作用的方法"></a>清除浮动副作用的方法</h2><ul><li><p>父级元素定义高度</p></li><li><p>父级元素<code>overflow: hidden;</code></p><ul><li><strong>原理：</strong>BFC(Block formatting context)，块级格式化上下文，它是一个独立的布局环境，其中的元素不受外界影响，外界的元素也不会被其中的元素影响</li></ul></li><li><p>父级定义伪类</p><ul><li><p><strong>原理：</strong>parent:after 添加<code>clear: both;</code>样式，其兄弟元素（child）浮动对它无影响，既然浮动对它无影响，则会正常布局，到浮动元素下方（parent:after 有<code>display: block;</code>，独占一行），由于 parent:after 在文档流中，所以父元素会被撑开</p></li><li><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- DOM 结构 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"parent"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"child"</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- 此处为 parrent:after 元素位置 --&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure></li><li><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* 样式 */</span></span><br><span class="line"><span class="selector-class">.child</span> &#123;</span><br><span class="line">    <span class="attribute">width</span>: <span class="number">100px</span>;</span><br><span class="line">    <span class="attribute">height</span>: <span class="number">100px</span>;</span><br><span class="line">    <span class="attribute">background-color</span>: red;</span><br><span class="line">    <span class="attribute">float</span>: left;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-class">.parent</span><span class="selector-pseudo">:after</span> &#123;</span><br><span class="line">    <span class="attribute">content</span>: <span class="string">""</span>;</span><br><span class="line">    <span class="attribute">display</span>: block;</span><br><span class="line">    <span class="attribute">height</span>: <span class="number">0</span>;</span><br><span class="line">    <span class="attribute">visibility</span>: hidden;</span><br><span class="line">    <span class="attribute">clear</span>: both;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul></li></ul><h2 id="BFC"><a href="#BFC" class="headerlink" title="BFC"></a>BFC</h2><p><strong>定义</strong><br>BFC(Block formatting context)，块级格式化上下文，它是一个独立的布局环境，其中的元素不受外界影响，外界的元素也不会被其中的元素影响。<br>BFC 就好比是快递盒子，无论盒子里的东西如何排列，都不会影响快递车里快递怎么排列，反之亦然。</p><p><strong>创建 BFC</strong>  </p><ul><li>float 值不为 none</li><li>position 值不为 static 或者 relative</li><li>display 值为 inline-block、flex、inline-flex、table-caption、table-cell</li><li>overflow 值不为 visible</li></ul><p><strong>应用</strong></p><ul><li>相邻元素 margin 重叠<ul><li>给其中一个元素做 BFC</li></ul></li><li>浮动导致父级高度丢失<ul><li>给父级元素做 BFC</li></ul></li></ul><h2 id="行内块元素并排时的间隙解决方法"><a href="#行内块元素并排时的间隙解决方法" class="headerlink" title="行内块元素并排时的间隙解决方法"></a>行内块元素并排时的间隙解决方法</h2><ul><li>原因：行内元素排列，空白、回车、换行会被浏览器处理成一个空白符；</li><li>解决方法：父元素设置<code>font-size: 0;</code>，子元素设置正确的字体大小。</li></ul><p>更新中······</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&amp;emsp;&amp;emsp;本片文章将会每周不定期更新不定数量面试题，毕竟质量才是关键。&lt;br&gt;&amp;emsp;&amp;emsp;实践是检验真理的唯一标准！看题不记题，看题要做题！&lt;br&gt;&amp;emsp;&amp;emsp;面试是一个学习交流的过程，抱着虚心求教的心，人无完人，祝你变得更优秀！&lt;/p
      
    
    </summary>
    
      <category term="前端" scheme="http://huishanyi.club/categories/%E5%89%8D%E7%AB%AF/"/>
    
    
      <category term="前端面试题" scheme="http://huishanyi.club/tags/%E5%89%8D%E7%AB%AF%E9%9D%A2%E8%AF%95%E9%A2%98/"/>
    
  </entry>
  
  <entry>
    <title>HTML面试题</title>
    <link href="http://huishanyi.club/2020/05/29/%E5%89%8D%E7%AB%AF%E9%9D%A2%E8%AF%95%E9%A2%98/HTML%E9%9D%A2%E8%AF%95%E9%A2%98/"/>
    <id>http://huishanyi.club/2020/05/29/前端面试题/HTML面试题/</id>
    <published>2020-05-28T23:51:41.000Z</published>
    <updated>2020-07-07T21:45:28.629Z</updated>
    
    <content type="html"><![CDATA[<p>&emsp;&emsp;本片文章将会每周不定期更新不定数量面试题，毕竟质量才是关键。<br>&emsp;&emsp;实践是检验真理的唯一标准！看题不记题，看题要做题！<br>&emsp;&emsp;面试是一个学习交流的过程，抱着虚心求教的心，人无完人，祝你变得更优秀！</p><h2 id="HTML5-和-HTML4-区别"><a href="#HTML5-和-HTML4-区别" class="headerlink" title="HTML5 和 HTML4 区别"></a>HTML5 和 HTML4 区别</h2><ul><li><p>HTML5 使用<code>&lt;!DOCTYPE html&gt;</code>对文档类型进行申明</p></li><li><p>HTML5 文档解析标准，不再基于 SGML（Standard Generalized Markup Language）标准</p></li><li><p>HTML5 增加了语义标签（<code>&lt;header&gt;、&lt;footer&gt;、&lt;section&gt;、&lt;article&gt;、&lt;nav&gt;、&lt;hgroup&gt;、&lt;aside&gt;、&lt;figure&gt;</code>）</p></li><li><p>HTML5 废除了部分样式标签（<code>&lt;big&gt;、&lt;u&gt;、&lt;font&gt;、&lt;basefont&gt;、&lt;center&gt;、&lt;s&gt;、&lt;tt&gt;</code>）</p></li><li><p>HTML5 实现了多媒体中的音频和视频功能（<code>&lt;audio&gt;、&lt;video&gt;</code>）</p></li><li><p>HTML5 属性</p><ul><li><p>增强了<code>&lt;input&gt;</code>标签的 type 属性</p><ul><li><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- 此类型要求输入格式正确的email地址 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">email</span> &gt;</span></span><br><span class="line"><span class="comment">&lt;!-- 要求输入格式正确的URL地址  --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">url</span> &gt;</span></span><br><span class="line"><span class="comment">&lt;!-- 要求输入格式数字，默认会有上下两个按钮 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">number</span> &gt;</span></span><br><span class="line"><span class="comment">&lt;!-- 时间系列，但目前只有 Opera和Chrome支持 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">date</span> &gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">time</span> &gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">datetime</span> &gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">datetime-local</span> &gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">month</span> &gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">week</span> &gt;</span></span><br><span class="line"><span class="comment">&lt;!-- 默认占位文字 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">text</span> <span class="attr">placeholder</span>=<span class="string">"your message"</span> &gt;</span></span><br><span class="line"><span class="comment">&lt;!-- 默认聚焦属性 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">text</span> <span class="attr">autofacus</span>=<span class="string">"true"</span> &gt;</span></span><br></pre></td></tr></table></figure></li></ul></li><li><p>增加了<code>&lt;meta&gt;</code>标签的 charset 属性 和<code>&lt;script&gt;</code>的 async 属性</p><ul><li><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- meta标签增加charset属性 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">"utf-8"</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- script标签增加async属性 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">async</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure></li></ul></li><li><p>部分属性名默认具有 boolean 属性</p><ul><li><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- 只写属性名默认为true --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">"checkbox"</span>  <span class="attr">checked</span>/&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- 属性名="属性名"也为true --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">"checkbox"</span>  <span class="attr">checked</span>=<span class="string">"checked"</span>/&gt;</span></span><br></pre></td></tr></table></figure></li></ul></li></ul></li><li><p>HTML5 新增 WebStorage（localStorage 和 sessionStorage）</p></li><li><p>HTML5 引入了应用程序缓存器(application cache)，可对web进行缓存，在没有网络的情况下使用，通过创建cache manifest文件,创建应用缓存，为PWA(Progressive Web App)提供了底层的技术支持。</p></li></ul><h2 id="meta-标签属性"><a href="#meta-标签属性" class="headerlink" title="meta 标签属性"></a>meta 标签属性</h2><ul><li><p>charset 属性</p><ul><li><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- 页面文档编码格式 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">"utf-8"</span>&gt;</span></span><br></pre></td></tr></table></figure></li></ul></li><li><p>name + content 属性</p><ul><li><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- 网页作者 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">meta</span> <span class="attr">name</span>=<span class="string">"author"</span> <span class="attr">content</span>=<span class="string">""</span>/&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- 网页地址 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">meta</span> <span class="attr">name</span>=<span class="string">"website"</span> <span class="attr">content</span>=<span class="string">""</span>/&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- 网页版权信息 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">meta</span> <span class="attr">name</span>=<span class="string">"copyright"</span> <span class="attr">content</span>=<span class="string">""</span>/&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- 网页关键字（多个关键字以英文逗号‘,’隔开）, 用于SEO --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">meta</span> <span class="attr">name</span>=<span class="string">"keywords"</span> <span class="attr">content</span>=<span class="string">"html,css,js"</span>/&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- 网页描述 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">meta</span> <span class="attr">name</span>=<span class="string">"description"</span> <span class="attr">content</span>=<span class="string">"good good study"</span>/&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- 搜索引擎索引方式，一般为all，不用深究 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">meta</span> <span class="attr">name</span>=<span class="string">"robots"</span> <span class="attr">content</span>=<span class="string">"all"</span> /&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- 移动端常用视口设置 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">meta</span> <span class="attr">name</span>=<span class="string">"viewport"</span> <span class="attr">content</span>=<span class="string">"width=device-width,initial-scale=1.0,maximum-scale=1.0, user-scalable=no"</span>/&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- </span></span><br><span class="line"><span class="comment">    viewport参数详解：</span></span><br><span class="line"><span class="comment">    width：宽度（数值 / device-width）（默认为980 像素）</span></span><br><span class="line"><span class="comment">    height：高度（数值 / device-height）</span></span><br><span class="line"><span class="comment">    initial-scale：初始的缩放比例 （0&lt;范围&lt;=10）</span></span><br><span class="line"><span class="comment">    minimum-scale：允许用户缩放到的最小比例</span></span><br><span class="line"><span class="comment">    maximum-scale：允许用户缩放到的最大比例</span></span><br><span class="line"><span class="comment">    user-scalable：用户是否可以手动缩 (no,yes)</span></span><br><span class="line"><span class="comment">--&gt;</span></span><br></pre></td></tr></table></figure></li></ul></li><li><p>http-equiv 属性</p><ul><li><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- expires指定网页的过期时间。一旦网页过期，必须从服务器上下载。 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">meta</span> <span class="attr">http-equiv</span>=<span class="string">"expires"</span> <span class="attr">content</span>=<span class="string">"Fri, 12 Jan 2020 18:18:18 GMT"</span>/&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- 等待一定的时间刷新或跳转到其他url。下面1表示1秒 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">meta</span> <span class="attr">http-equiv</span>=<span class="string">"refresh"</span> <span class="attr">content</span>=<span class="string">"1; url=https://www.baidu.com"</span>/&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- 禁止浏览器从本地缓存中读取网页，即浏览器一旦离开网页在无法连接网络的情况下就无法访问到页面。 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">meta</span> <span class="attr">http-equiv</span>=<span class="string">"pragma"</span> <span class="attr">content</span>=<span class="string">"no-cache"</span>/&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- 设置cookie的一种方式，并且可以指定过期时间 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">meta</span> <span class="attr">http-equiv</span>=<span class="string">"set-cookie"</span> <span class="attr">content</span>=<span class="string">"name=value expires=Fri, 12 Jan 2001 18:18:18 GMT,path=/"</span>/&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- 使用浏览器版本 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">meta</span> <span class="attr">http-equiv</span>=<span class="string">"X-UA-Compatible"</span> <span class="attr">content</span>=<span class="string">"IE=edge,chrome=1"</span> /&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- 针对WebApp全屏模式，隐藏状态栏/设置状态栏颜色，content的值为default | black | black-translucent --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">meta</span> <span class="attr">name</span>=<span class="string">"apple-mobile-web-app-status-bar-style"</span> <span class="attr">content</span>=<span class="string">"black-translucent"</span> /&gt;</span></span><br></pre></td></tr></table></figure></li></ul></li></ul><h2 id="script-标签中的-defer-和-async属性"><a href="#script-标签中的-defer-和-async属性" class="headerlink" title="script 标签中的 defer 和 async属性"></a>script 标签中的 defer 和 async属性</h2><ul><li>defer：页面加载完成再进行脚本解析；</li><li>async：HTML5 新特性，异步执行脚本。</li></ul><h2 id="href-与-src-的区别"><a href="#href-与-src-的区别" class="headerlink" title="href 与 src 的区别"></a>href 与 src 的区别</h2><ul><li>href<ul><li>Hypertext Reference，超文本链接</li><li>触发该功能，地址栏会产生变化，可以做地址跳转，也可以做锚点功能</li><li>浏览器解析时不会停止对当前文档的处理</li></ul></li><li>src<ul><li>source，资源</li><li>对资源进行下载引入页面作为内容</li><li>浏览器解析时会暂停对文档的处理</li></ul></li></ul><p>更新中······</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&amp;emsp;&amp;emsp;本片文章将会每周不定期更新不定数量面试题，毕竟质量才是关键。&lt;br&gt;&amp;emsp;&amp;emsp;实践是检验真理的唯一标准！看题不记题，看题要做题！&lt;br&gt;&amp;emsp;&amp;emsp;面试是一个学习交流的过程，抱着虚心求教的心，人无完人，祝你变得更优秀！&lt;/p
      
    
    </summary>
    
      <category term="前端" scheme="http://huishanyi.club/categories/%E5%89%8D%E7%AB%AF/"/>
    
    
      <category term="前端面试题" scheme="http://huishanyi.club/tags/%E5%89%8D%E7%AB%AF%E9%9D%A2%E8%AF%95%E9%A2%98/"/>
    
  </entry>
  
  <entry>
    <title>原生JS面试题</title>
    <link href="http://huishanyi.club/2020/05/29/%E5%89%8D%E7%AB%AF%E9%9D%A2%E8%AF%95%E9%A2%98/%E5%8E%9F%E7%94%9FJS%E9%9D%A2%E8%AF%95%E9%A2%98/"/>
    <id>http://huishanyi.club/2020/05/29/前端面试题/原生JS面试题/</id>
    <published>2020-05-28T23:46:33.000Z</published>
    <updated>2020-08-24T00:13:22.902Z</updated>
    
    <content type="html"><![CDATA[<p>&emsp;&emsp;本片文章将会每周不定期更新不定数量面试题，毕竟质量才是关键。<br>&emsp;&emsp;实践是检验真理的唯一标准！看题不记题，看题要做题！<br>&emsp;&emsp;面试是一个学习交流的过程，抱着虚心求教的心，人无完人，祝你变得更优秀！</p><h2 id="什么是防抖和节流？"><a href="#什么是防抖和节流？" class="headerlink" title="什么是防抖和节流？"></a>什么是防抖和节流？</h2><ul><li>防抖：事件连续多次触发，本次执行未完成时再一次（或多次）触发事件，以最后一次执行为准。例如：轮播图在自动播放时以3秒间隔轮播一次，第一次轮播开始，但在第2秒内用户手动触发轮播事件，那么第三次轮播将在1秒后执行，每3秒轮播一次中间却出现了一次等待时间为1秒的轮播（就好像抖了一下），而我们消除这一尴尬现象（轮播事件最前方插一行清除定时器的代码）的过程就是<strong>防抖</strong>。</li><li>节流：事件连续多次触发，但在指定时间内只触发一次。例如：还是轮播图，自动播放以3秒间隔轮播一次，无论在这3秒内触发多少次，他都是3秒执行一次轮播。</li></ul><h2 id="JS操作数组的方法"><a href="#JS操作数组的方法" class="headerlink" title="JS操作数组的方法"></a>JS操作数组的方法</h2><p>参考 <a href="/2020/07/13/JS/JS操作数组/" target="_blank">JS操作数组</a>。</p><h2 id="JS操作字符串的方法"><a href="#JS操作字符串的方法" class="headerlink" title="JS操作字符串的方法"></a>JS操作字符串的方法</h2><p>参考 <a href="/2020/07/13/JS/JS操作字符串/" target="_blank">JS操作字符串</a>。</p><h2 id="谈谈对JS中变量提升的理解"><a href="#谈谈对JS中变量提升的理解" class="headerlink" title="谈谈对JS中变量提升的理解"></a>谈谈对JS中变量提升的理解</h2><p>JS 中函数声明和变量声明总会被提升到作用域顶部（仅是声明提升到顶部，赋值并不会提升）。</p><p>先来看一段代码  </p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// test_1：控制台报错“Uncaught ReferenceError: x is not defined”，并不会输出 1</span></span><br><span class="line"><span class="built_in">console</span>.log(x);</span><br><span class="line"><span class="built_in">console</span>.log(<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// test_2：编码过程中往往需要在未声明前使用部分代码，且不希望报错中断整体代码</span></span><br><span class="line"><span class="comment">// 该示例将会分别输出 undefined 与 1，此时不报错就是因为 var 对 x 的生命提升到了作用于顶部</span></span><br><span class="line"><span class="built_in">console</span>.log(x);</span><br><span class="line"><span class="built_in">console</span>.log(<span class="number">1</span>);</span><br><span class="line"><span class="keyword">var</span> x = <span class="number">2</span>; <span class="comment">// 不过变量提升并不推荐，因此 ES6 中的 let 与 const 声明并不存在变量提升</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// test_3：函数式声明也存在变量提升，不过建议使用 const 声明函数，避免变量与函数冲突</span></span><br><span class="line"><span class="comment">// 此时会输出 function x()&#123;return 'It is a function !' &#125;，你可能说覆盖声明，好理解，那么看 test_4</span></span><br><span class="line"><span class="built_in">console</span>.log(x);</span><br><span class="line"><span class="keyword">var</span> x = <span class="number">2</span>;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">x</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">'It is a function !'</span> </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// test_4：函数式声明会赋值，函数声明的权重总是高一些，所以最终结果往往是指向函数声明的引用。</span></span><br><span class="line"><span class="comment">// 覆盖可以直接 x=1 ，则会输出 1，仅做值的覆盖时不存在声明的权重冲突</span></span><br><span class="line"><span class="comment">// 因此下方输出同 test_3，而不是 undefined</span></span><br><span class="line"><span class="built_in">console</span>.log(x);</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">x</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">'It is a function !'</span> </span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> x = <span class="number">2</span>;</span><br></pre></td></tr></table></figure><h2 id="谈谈对JS中use-strict的理解"><a href="#谈谈对JS中use-strict的理解" class="headerlink" title="谈谈对JS中use strict的理解"></a>谈谈对JS中use strict的理解</h2><p>use strict 是 ES5 的概念，是一种运行时自动执行更严格的 JavaScript 代码解析和错误处理的方法。如果代码错误被忽略或失败，将会产生错误或抛出异常，ES6 模块默认使用 use strict，开发底层框架时保证兼容性基于 ES5 会声明（源码中会出现）。</p><p>优秀的报错机制大大的减少了排错的时间，并且消除了隐藏的风险问题。</p><p><strong>严格模式限制</strong></p><ul><li>变量必须声明后再使用</li><li>函数的参数不能有同名属性，否则报错</li><li>不能使用 with 语句</li><li>不能对只读属性赋值，否则报错</li><li>不能使用前缀 0 表示八进制数，否则报错</li><li>不能删除不可删除的属性，否则报错</li><li>不能删除变量 delete prop ，会报错，只能删除属性 selete global[prop]</li><li>eval 不会在它的外层作用域引入变量</li><li>eval 和 arguments 不能被重新赋值</li><li>arguments 不会自动反映函数参数的变化</li><li>不能使用 arguments.callee</li><li>不能使用 arguments.caller</li><li>禁止 this 指向全局对象</li><li>不能使用 fn.caller 和 fn.arguments 获取函数调用的堆栈</li><li>增加了保留字（比如 protected、static 和 interface）</li></ul><h2 id="手写一个compose函数"><a href="#手写一个compose函数" class="headerlink" title="手写一个compose函数"></a>手写一个compose函数</h2><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> compose = <span class="function">(<span class="params">...arg</span>) =&gt;</span> <span class="function"><span class="params">data</span> =&gt;</span> arg.reduce(<span class="function">(<span class="params">total,curentValue</span>) =&gt;</span> curentValue(total), data);</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&amp;emsp;&amp;emsp;本片文章将会每周不定期更新不定数量面试题，毕竟质量才是关键。&lt;br&gt;&amp;emsp;&amp;emsp;实践是检验真理的唯一标准！看题不记题，看题要做题！&lt;br&gt;&amp;emsp;&amp;emsp;面试是一个学习交流的过程，抱着虚心求教的心，人无完人，祝你变得更优秀！&lt;/p
      
    
    </summary>
    
      <category term="前端" scheme="http://huishanyi.club/categories/%E5%89%8D%E7%AB%AF/"/>
    
    
      <category term="前端面试题" scheme="http://huishanyi.club/tags/%E5%89%8D%E7%AB%AF%E9%9D%A2%E8%AF%95%E9%A2%98/"/>
    
  </entry>
  
  <entry>
    <title>博客搭建——后台管理系统搭建</title>
    <link href="http://huishanyi.club/2020/04/07/%E9%A1%B9%E7%9B%AE%E5%AE%9E%E4%BE%8B/%E5%8D%9A%E5%AE%A2%E6%90%AD%E5%BB%BA/%E5%8D%9A%E5%AE%A2%E6%90%AD%E5%BB%BA%E2%80%94%E2%80%94%E5%90%8E%E5%8F%B0%E7%AE%A1%E7%90%86%E7%B3%BB%E7%BB%9F%E6%90%AD%E5%BB%BA/"/>
    <id>http://huishanyi.club/2020/04/07/项目实例/博客搭建/博客搭建——后台管理系统搭建/</id>
    <published>2020-04-07T03:13:17.000Z</published>
    <updated>2020-07-07T21:45:28.637Z</updated>
    
    <content type="html"><![CDATA[<p>&emsp;&emsp;动态网站（存在数据交互的网站）通常分为前台 UI 界面与后台管理系统，在这前、后台分离开发的时代，开发并没有先后顺序，有图就尽管画，只要接口对的上。</p><h2 id="项目名称"><a href="#项目名称" class="headerlink" title="项目名称"></a>项目名称</h2><p>sumblog_manager</p><h2 id="技术栈"><a href="#技术栈" class="headerlink" title="技术栈"></a>技术栈</h2><p>Ts + Node + React全家桶 + AntD</p><h2 id="功能概述"><a href="#功能概述" class="headerlink" title="功能概述"></a>功能概述</h2><ul><li>登录（无注册功能，仅由超管添加）</li><li>用户管理（低权限用户禁止查看高权限用户）</li><li>文章管理（仅做删除、警告，编辑功能归前台）</li><li>日志管理（记录何时何地何设备进行了何操作）</li><li>安全设置（特定级别用户可在前台选择相应的代码保护）</li><li>支持移动化（时时管理）</li><li>自定义主题（主题色、字体调整、背景图）</li><li>新功能持续添加中</li></ul><h2 id="配置-Node-环境"><a href="#配置-Node-环境" class="headerlink" title="配置 Node 环境"></a>配置 Node 环境</h2><p>参考 <a href="https://huishanyi.club/2019/07/16/NodeJS/NodeJS%E5%AE%89%E8%A3%85%E6%95%99%E7%A8%8B/" target="_blank">NodeJS安装教程</a>。  </p><p>建议版本：node v12.16.1+、npm v6.13.4+</p><h2 id="了解-NPM-常用命令"><a href="#了解-NPM-常用命令" class="headerlink" title="了解 NPM 常用命令"></a>了解 NPM 常用命令</h2><p>参考 <a href="https://huishanyi.club/2019/07/16/NodeJS/NPM%E4%BB%8B%E7%BB%8D/" target="_blank">NPM介绍</a>。</p><h2 id="创建-React-应用"><a href="#创建-React-应用" class="headerlink" title="创建 React 应用"></a>创建 React 应用</h2><p>参考 <a href="https://huishanyi.club/2019/09/05/React/create-react-app/" target="_blank">create-react-app</a>（我创建的应用名称为 sumblog_manager）。</p><p>创建 React Ts 应用命令：<code>npx create-react-app ts_app_name --template typescript</code>。</p><h2 id="扩展webpack配置"><a href="#扩展webpack配置" class="headerlink" title="扩展webpack配置"></a>扩展webpack配置</h2><p>参考 <a href="https://huishanyi.club/2019/09/09/React/react-app-rewired/" target="_blank">react-app-rewired</a>。</p><h2 id="目录结构"><a href="#目录结构" class="headerlink" title="目录结构"></a>目录结构</h2><p>由<code>create-react-app</code>生成目录改造而来（暂时仅改造<code>src</code>目录）。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">src</span><br><span class="line">├── components（公共组件）</span><br><span class="line">├── pages</span><br><span class="line">│   ├── article（文章管理）</span><br><span class="line">│   ├── log（日志管理）</span><br><span class="line">│   ├── login（登录）</span><br><span class="line">│   ├── safety（安全管理）</span><br><span class="line">│   ├── theme（主题管理）</span><br><span class="line">│   └── user（用户管理）</span><br><span class="line">│       ├── PersonalInfo（个人信息）</span><br><span class="line">│       └── UserList（用户列表）</span><br><span class="line">└── router（路由）</span><br></pre></td></tr></table></figure><h2 id="添加路由"><a href="#添加路由" class="headerlink" title="添加路由"></a>添加路由</h2><p>参考 <a href="https://huishanyi.club/2019/09/16/React/react-router与react-router-dom/" target="_blank">react-router与react-router-dom</a>。</p><h2 id="添加状态管理工具"><a href="#添加状态管理工具" class="headerlink" title="添加状态管理工具"></a>添加状态管理工具</h2><p>参考 <a href="https://huishanyi.club/2019/11/04/React/Redux与react-redux/" target="_blank">Redux与react-redux</a>。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&amp;emsp;&amp;emsp;动态网站（存在数据交互的网站）通常分为前台 UI 界面与后台管理系统，在这前、后台分离开发的时代，开发并没有先后顺序，有图就尽管画，只要接口对的上。&lt;/p&gt;
&lt;h2 id=&quot;项目名称&quot;&gt;&lt;a href=&quot;#项目名称&quot; class=&quot;headerlin
      
    
    </summary>
    
      <category term="项目实例" scheme="http://huishanyi.club/categories/%E9%A1%B9%E7%9B%AE%E5%AE%9E%E4%BE%8B/"/>
    
    
      <category term="博客搭建" scheme="http://huishanyi.club/tags/%E5%8D%9A%E5%AE%A2%E6%90%AD%E5%BB%BA/"/>
    
  </entry>
  
  <entry>
    <title>RESTfulAPI</title>
    <link href="http://huishanyi.club/2020/03/16/%E6%8E%A5%E5%8F%A3/RESTfulAPI/"/>
    <id>http://huishanyi.club/2020/03/16/接口/RESTfulAPI/</id>
    <published>2020-03-16T02:39:47.000Z</published>
    <updated>2020-07-07T21:45:28.631Z</updated>
    
    <content type="html"><![CDATA[<p>&emsp;&emsp;RESTful 是一个符合架构原理、功能强、性能好、适宜通信的架构。适用于移动互联网厂商作为业务使能接口的场景。</p><h2 id="REST"><a href="#REST" class="headerlink" title="REST"></a>REST</h2><p>REST（<strong>Re</strong>presentational <strong>S</strong>tate <strong>T</strong>ransfer，表征性状态转移），万维网软件架构风格，它首次出现在 2000 年 Roy Fielding 的博士论文中，Roy Fielding是 HTTP 规范的主要编写者之一。</p><h3 id="六大原则"><a href="#六大原则" class="headerlink" title="六大原则"></a>六大原则</h3><ul><li><strong>客户-服务器（Client-Server，C/S）：</strong>两端分离（服务端专注数据存储；前端专注用户界面）；</li><li><strong>无状态：</strong>所有用户会话信息都保存在客户端，简化了服务端代码，利于服务端故障恢复；每次请求必须包括所有信息，接口透明；</li><li><strong>缓存：</strong>所有服务端响应都要被标明是否可缓存，减少前后端交互，提升了性能；</li><li><strong>接口统一：</strong>不同接口拥有相同的规范，易用，实现了前后端分离；<ul><li>一个 URI 代表一种资源</li><li>通过 JSON 或 XML 表述操作资源</li><li>超媒体作为应用状态引擎（接口嵌套可通过超链接跳转）</li></ul></li><li><strong>分层系统：</strong>仅相邻层透明，更安全；</li><li><strong>按需代码：</strong>客户端可下载运行服务器传来的代码，简化了客户端。</li></ul><h2 id="RESTful"><a href="#RESTful" class="headerlink" title="RESTful"></a>RESTful</h2><p>满足 REST 风格的架构即为 RESTful。</p><h2 id="RESTful-API"><a href="#RESTful-API" class="headerlink" title="RESTful API"></a>RESTful API</h2><p>满足 REST 风格的 API(<strong>A</strong>pplication <strong>P</strong>rogram <strong>I</strong>nterface，允许两个程序相互通信的代码)。</p><h3 id="设计规范"><a href="#设计规范" class="headerlink" title="设计规范"></a>设计规范</h3><p>设计规范转自<a href="http://www.ruanyifeng.com/blog/2014/05/restful_api.html" target="_blank">阮一峰的网络日志 ———— RESTful API 设计指南</a></p><h4 id="协议"><a href="#协议" class="headerlink" title="协议"></a>协议</h4><p>API与用户的通信协议，总是使用HTTPS协议（防止页面篡改）。</p><h4 id="域名"><a href="#域名" class="headerlink" title="域名"></a>域名</h4><p>应该尽量将API部署在专用域名之下。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">https://api.example.com</span><br></pre></td></tr></table></figure><p>如果确定API很简单，不会有进一步扩展，可以考虑放在主域名下。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">https://example.org/api/</span><br></pre></td></tr></table></figure><h4 id="版本"><a href="#版本" class="headerlink" title="版本"></a>版本</h4><p>应该将API的版本号放入URL。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">https://api.example.com/v1/</span><br></pre></td></tr></table></figure><h4 id="路径"><a href="#路径" class="headerlink" title="路径"></a>路径</h4><p>路径又称”终点”（endpoint），表示API的具体网址。</p><p>在RESTful架构中，每个网址代表一种资源（resource），所以网址中不能有动词，只能有名词，而且所用的名词往往与数据库的表格名对应。一般来说，数据库中的表都是同种记录的”集合”（collection），所以API中的名词也应该使用复数。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">https://api.example.com/v1/users</span><br><span class="line">https://api.example.com/v1/articles</span><br></pre></td></tr></table></figure><h4 id="HTTP-动词"><a href="#HTTP-动词" class="headerlink" title="HTTP 动词"></a>HTTP 动词</h4><p>对于资源的具体操作类型，由HTTP动词表示。</p><p>常用的HTTP动词有下面五个（括号里是对应的SQL命令）。</p><ul><li>GET（SELECT）：从服务器取出资源（一项或多项）。</li><li>POST（CREATE）：在服务器新建一个资源。</li><li>PUT（UPDATE）：在服务器更新资源（客户端提供改变后的完整资源）。</li><li>PATCH（UPDATE）：在服务器更新资源（客户端提供改变的属性）。</li><li>DELETE（DELETE）：从服务器删除资源。</li><li>HEAD：获取资源的元数据。</li><li>OPTIONS：获取信息，关于资源的哪些属性是客户端可以改变的。</li></ul><h4 id="过滤信息"><a href="#过滤信息" class="headerlink" title="过滤信息"></a>过滤信息</h4><p>如果记录数量很多，服务器不可能都将它们返回给用户。API应该提供参数，过滤返回结果。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">?limit=10：指定返回记录的数量</span><br><span class="line">?offset=10：指定返回记录的开始位置。</span><br><span class="line">?page=2&amp;per_page=100：指定第几页，以及每页的记录数。</span><br><span class="line">?sortby=name&amp;order=asc：指定返回结果按照哪个属性排序，以及排序顺序。</span><br><span class="line">?users_id=1：指定筛选条件</span><br></pre></td></tr></table></figure><p>参数的设计允许存在冗余，即允许API路径和URL参数偶尔有重复。比如，GET /zoo/ID/animals 与 GET /animals?zoo_id=ID 的含义是相同的。</p><h4 id="状态码"><a href="#状态码" class="headerlink" title="状态码"></a>状态码</h4><p>服务器向用户返回的状态码和提示信息，常见的有以下一些（方括号中是该状态码对应的HTTP动词）。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">200 OK - [GET]：服务器成功返回用户请求的数据，该操作是幂等的（Idempotent）。</span><br><span class="line">201 CREATED - [POST/PUT/PATCH]：用户新建或修改数据成功。</span><br><span class="line">202 Accepted - [*]：表示一个请求已经进入后台排队（异步任务）</span><br><span class="line">204 NO CONTENT - [DELETE]：用户删除数据成功。</span><br><span class="line">400 INVALID REQUEST - [POST/PUT/PATCH]：用户发出的请求有错误，服务器没有进行新建或修改数据的操作，该操作是幂等的。</span><br><span class="line">401 Unauthorized - [*]：表示用户没有权限（令牌、用户名、密码错误）。</span><br><span class="line">403 Forbidden - [*] 表示用户得到授权（与401错误相对），但是访问是被禁止的。</span><br><span class="line">404 NOT FOUND - [*]：用户发出的请求针对的是不存在的记录，服务器没有进行操作，该操作是幂等的。</span><br><span class="line">406 Not Acceptable - [GET]：用户请求的格式不可得（比如用户请求JSON格式，但是只有XML格式）。</span><br><span class="line">410 Gone -[GET]：用户请求的资源被永久删除，且不会再得到的。</span><br><span class="line">422 Unprocesable entity - [POST/PUT/PATCH] 当创建一个对象时，发生一个验证错误。</span><br><span class="line">500 INTERNAL SERVER ERROR - [*]：服务器发生错误，用户将无法判断发出的请求是否成功。</span><br></pre></td></tr></table></figure><p><a href="https://baike.baidu.com/item/HTTP%E7%8A%B6%E6%80%81%E7%A0%81/5053660?fr=aladdin" target="_blank">查看所有状态码信息</a></p><h4 id="错误处理"><a href="#错误处理" class="headerlink" title="错误处理"></a>错误处理</h4><p>如果状态码是4xx，就应该向用户返回出错信息。一般来说，返回的信息中将error作为键名，出错信息作为键值即可。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    error: &quot;Invalid API key&quot;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="返回结果"><a href="#返回结果" class="headerlink" title="返回结果"></a>返回结果</h4><p>针对不同操作，服务器向用户返回的结果应该符合以下规范。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">GET /collection：返回资源对象的列表（数组）</span><br><span class="line">GET /collection/resource：返回单个资源对象</span><br><span class="line">POST /collection：返回新生成的资源对象</span><br><span class="line">PUT /collection/resource：返回完整的资源对象</span><br><span class="line">PATCH /collection/resource：返回完整的资源对象</span><br><span class="line">DELETE /collection/resource：返回一个空文档</span><br></pre></td></tr></table></figure><h4 id="Hypermedia-API"><a href="#Hypermedia-API" class="headerlink" title="Hypermedia API"></a>Hypermedia API</h4><p>RESTful API最好做到Hypermedia，即返回结果中提供链接，连向其他API方法，使得用户不查文档，也知道下一步应该做什么。</p><p>比如，当用户向api.example.com的根目录发出请求，会得到这样一个文档。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&#123;&quot;link&quot;: &#123;</span><br><span class="line">  &quot;rel&quot;:   &quot;collection https://www.example.com/users&quot;,</span><br><span class="line">  &quot;href&quot;:  &quot;https://api.example.com/users&quot;,</span><br><span class="line">  &quot;title&quot;: &quot;List of users&quot;,</span><br><span class="line">  &quot;type&quot;:  &quot;application/vnd.yourformat+json&quot;</span><br><span class="line">&#125;&#125;</span><br></pre></td></tr></table></figure><p>上面代码表示，文档中有一个link属性，用户读取这个属性就知道下一步该调用什么API了。rel表示这个API与当前网址的关系（collection关系，并给出该collection的网址），href表示API的路径，title表示API的标题，type表示返回类型。</p><h4 id="API-身份认证"><a href="#API-身份认证" class="headerlink" title="API 身份认证"></a>API 身份认证</h4><p>API 的身份认证可使用 OAuth 2.0 或 JWT（保证用户数据安全）。</p><h4 id="限流"><a href="#限流" class="headerlink" title="限流"></a>限流</h4><p>防止网站攻击，频繁请求导致服务器挂掉。</p><h3 id="经典实例"><a href="#经典实例" class="headerlink" title="经典实例"></a>经典实例</h3><p>最全最可靠的实例 ———— <a href="https://developer.github.com/v3/" target="_blank">GitHub REST API V3 接口</a>。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&amp;emsp;&amp;emsp;RESTful 是一个符合架构原理、功能强、性能好、适宜通信的架构。适用于移动互联网厂商作为业务使能接口的场景。&lt;/p&gt;
&lt;h2 id=&quot;REST&quot;&gt;&lt;a href=&quot;#REST&quot; class=&quot;headerlink&quot; title=&quot;REST&quot;&gt;&lt;/
      
    
    </summary>
    
      <category term="后端" scheme="http://huishanyi.club/categories/%E5%90%8E%E7%AB%AF/"/>
    
    
      <category term="接口" scheme="http://huishanyi.club/tags/%E6%8E%A5%E5%8F%A3/"/>
    
  </entry>
  
  <entry>
    <title>MySQL常见问题</title>
    <link href="http://huishanyi.club/2020/03/09/%E6%95%B0%E6%8D%AE%E5%BA%93/MySQL%E5%B8%B8%E8%A7%81%E9%97%AE%E9%A2%98/"/>
    <id>http://huishanyi.club/2020/03/09/数据库/MySQL常见问题/</id>
    <published>2020-03-09T05:56:04.000Z</published>
    <updated>2020-07-07T21:45:28.632Z</updated>
    
    <content type="html"><![CDATA[<p>&emsp;&emsp;MySQL 常见问题汇总。碰到问题先看是什么原因，英文底子差就翻译下，只有找准问题才可以更快的找到解决方案。</p><h2 id="Client-does-not-support-authentication-protocol"><a href="#Client-does-not-support-authentication-protocol" class="headerlink" title="Client does not support authentication protocol"></a>Client does not support authentication protocol</h2><h3 id="问题描述"><a href="#问题描述" class="headerlink" title="问题描述"></a>问题描述</h3><p>客户端不支持身份验证协议。</p><h3 id="产生原因"><a href="#产生原因" class="headerlink" title="产生原因"></a>产生原因</h3><p>v8.0.4 开始 mysql 引入一个 caching_sha2_password 模块作为默认身份验证插件，以前版本通过 mysql_native_password 模块作为默认身份验证插件，当存在版本冲突时就会发生该问题。  </p><p>版本冲突举例：</p><ul><li>旧版本创建的数据库迁移到新版本使用，会自动切换身份验证方式，不会出现该错误；</li><li>npm 托管平台 mysql 包并未对此出代码进行更新，连接新版本数据库时会出现该错误。</li></ul><h3 id="解决方案"><a href="#解决方案" class="headerlink" title="解决方案"></a>解决方案</h3><ol><li>进入 mysql：输入命令<code>mysql -u root -p</code>（默认已进行 mysql 全局变量配置）；</li><li>提示输入密码，输入密码（无密码直接回车），回车，即可进入 mysql；</li><li>输入命令<code>ALTER USER &#39;root&#39;@&#39;localhost&#39; IDENTIFIED WITH mysql_native_password BY &#39;123456&#39;;</code>设置 mysql 验证方式为 mysql_native_password，并重置密码为 <code>123456</code>；</li><li>重启你的项目，你发现世界还是曾经的样子<del>~</del></li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&amp;emsp;&amp;emsp;MySQL 常见问题汇总。碰到问题先看是什么原因，英文底子差就翻译下，只有找准问题才可以更快的找到解决方案。&lt;/p&gt;
&lt;h2 id=&quot;Client-does-not-support-authentication-protocol&quot;&gt;&lt;a href=&quot;
      
    
    </summary>
    
      <category term="后端" scheme="http://huishanyi.club/categories/%E5%90%8E%E7%AB%AF/"/>
    
    
      <category term="数据库" scheme="http://huishanyi.club/tags/%E6%95%B0%E6%8D%AE%E5%BA%93/"/>
    
      <category term="MySQL" scheme="http://huishanyi.club/tags/MySQL/"/>
    
  </entry>
  
  <entry>
    <title>创建Node项目并上传至NPM</title>
    <link href="http://huishanyi.club/2020/03/05/NodeJS/%E5%88%9B%E5%BB%BANode%E9%A1%B9%E7%9B%AE%E5%B9%B6%E4%B8%8A%E4%BC%A0%E8%87%B3NPM/"/>
    <id>http://huishanyi.club/2020/03/05/NodeJS/创建Node项目并上传至NPM/</id>
    <published>2020-03-05T04:05:00.000Z</published>
    <updated>2020-07-07T21:45:28.624Z</updated>
    
    <content type="html"><![CDATA[<p>&emsp;&emsp;通过命令创建 NodeJS 项目，复用性较强的项目可上传至 NPM 包管理平台，下次项目使用可直接通过 <code>npm install</code> 命令拉取至新项目使用。</p><h2 id="创建-Node-项目"><a href="#创建-Node-项目" class="headerlink" title="创建 Node 项目"></a>创建 Node 项目</h2><p>打开命令面板，运行<code>npm init</code>生成 Node 项目目录。</p><ul><li>package name： 项目名称；</li><li>version: 版本；</li><li>description： 项目描述；</li><li>entry point： 默认项目入口；</li><li>test command： ；</li><li>git repository： 若需上传项目至 git，填写 git 仓库地址即可；</li><li>keywords： 项目关键字，多个关键字用逗号隔开，若上传至 NPM ，可通过关键字查询；</li><li>author： 项目作者；</li><li>license： 授权，直接回车进行公用。</li></ul><p><img src="/images/npm_init.png" alt="&quot;创建 NodeJS 项目&quot;" title="创建 NodeJS 项目"></p><h2 id="配置快速启动命令"><a href="#配置快速启动命令" class="headerlink" title="配置快速启动命令"></a>配置快速启动命令</h2><p>初始化完成后，项目根目录生成的<code>package.json</code>中添加如下命令：</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">"scripts":&#123;</span><br><span class="line">    "start":"node 入口文件相对目录",// 配置后可以直接运行 npm start 运行项目</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="配置自启动"><a href="#配置自启动" class="headerlink" title="配置自启动"></a>配置自启动</h2><p>node 项目启动后，每次更新代码，都需要手动重启项目，建议为项目配置自启动功能，节省开发时间。</p><ol><li>运行<code>npm install --save-dev nodemon</code>或<code>npm i -D nodemon</code>安装开发环境依赖；</li><li><code>package.json</code>中修改运行命令；<ul><li><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">"scripts": &#123;</span><br><span class="line">    "start": "nodemon 入口文件相对目录"</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul></li></ol><h2 id="代码编写"><a href="#代码编写" class="headerlink" title="代码编写"></a>代码编写</h2><p>根据功能需求编写代码。</p><h2 id="上传至-NPM"><a href="#上传至-NPM" class="headerlink" title="上传至 NPM"></a>上传至 NPM</h2><p>功能代码编写完成后，即可上传至 NPM 包管理平台，便于下次项目拉取。</p><h3 id="注册-NPM-账号"><a href="#注册-NPM-账号" class="headerlink" title="注册 NPM 账号"></a>注册 NPM 账号</h3><p>进入 <a href="https://www.npmjs.com/" target="_blank">NPM 官网</a>，进行账号注册。</p><h3 id="登录-NPM"><a href="#登录-NPM" class="headerlink" title="登录 NPM"></a>登录 NPM</h3><p>在项目根目录下打开命令面板，运行<code>npm login</code>填写相关信息进行登录。</p><h3 id="发布"><a href="#发布" class="headerlink" title="发布"></a>发布</h3><p>命令面板运行<code>npm publish</code>，完成发布。</p><h2 id="拉取项目"><a href="#拉取项目" class="headerlink" title="拉取项目"></a>拉取项目</h2><p>项目上传至 NPM 成功后，若要拉取，运行命令<code>npm install 包名</code>或<code>npm i 包名</code>进行拉取使用。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&amp;emsp;&amp;emsp;通过命令创建 NodeJS 项目，复用性较强的项目可上传至 NPM 包管理平台，下次项目使用可直接通过 &lt;code&gt;npm install&lt;/code&gt; 命令拉取至新项目使用。&lt;/p&gt;
&lt;h2 id=&quot;创建-Node-项目&quot;&gt;&lt;a href=&quot;#创建
      
    
    </summary>
    
      <category term="前端" scheme="http://huishanyi.club/categories/%E5%89%8D%E7%AB%AF/"/>
    
    
      <category term="NodeJS" scheme="http://huishanyi.club/tags/NodeJS/"/>
    
  </entry>
  
  <entry>
    <title>Node+Koa搭建服务端</title>
    <link href="http://huishanyi.club/2020/03/05/%E9%A1%B9%E7%9B%AE%E5%AE%9E%E4%BE%8B/Node+Koa%E6%90%AD%E5%BB%BA%E6%9C%8D%E5%8A%A1%E7%AB%AF/"/>
    <id>http://huishanyi.club/2020/03/05/项目实例/Node+Koa搭建服务端/</id>
    <published>2020-03-05T03:05:24.000Z</published>
    <updated>2020-07-07T21:45:28.637Z</updated>
    
    <content type="html"><![CDATA[<p>&emsp;&emsp;将 Node 项目中的数据库服务解耦，上传至 NPM 平台，方便之后项目复用。</p><h2 id="技能要求"><a href="#技能要求" class="headerlink" title="技能要求"></a>技能要求</h2><ul><li>了解 <a href="http://huishanyi.club/tags/NodeJS/" target="_blank">NodeJS</a>（v7.6.0+）</li><li>了解 <a href="https://koa.bootcss.com/" target="_blank">KoaJS</a>（koa2）</li><li>了解 <a href="https://huishanyi.club/2020/03/16/接口/RESTfulAPI/" target="_blank">RESTful API</a></li><li>了解 <a href="http://huishanyi.club/tags/MySQL/" target="_blank">MySQL</a> 或者 MongoDB</li><li>了解 postman</li></ul><h2 id="环境要求"><a href="#环境要求" class="headerlink" title="环境要求"></a>环境要求</h2><ul><li>Node v7.6.0+ 环境（参考 <a href="https://huishanyi.club/2019/07/16/NodeJS/NodeJS%E5%AE%89%E8%A3%85%E6%95%99%E7%A8%8B/" target="_blank">NodeJS 安装教程</a>）</li><li>数据库管理工具（二选一）<ul><li>MySQL（参考 <a href="https://huishanyi.club/2019/12/24/MySQL/MySQL安装建库建表/" target="_blank">MySQL安装建库建表</a>）</li><li>MongoDB</li></ul></li><li>网页请求调试工具（postman）</li></ul><h2 id="创建-Node-项目"><a href="#创建-Node-项目" class="headerlink" title="创建 Node 项目"></a>创建 Node 项目</h2><p>参考 <a href="https://huishanyi.club/2020/03/05/NodeJS/创建Node项目并上传至NPM/" target="_blank">创建 Node 项目并上传至 NPM</a>。</p><h2 id="服务端目录结构"><a href="#服务端目录结构" class="headerlink" title="服务端目录结构"></a>服务端目录结构</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">db-service</span><br><span class="line">├── app</span><br><span class="line">│   ├── controller（控制器目录）</span><br><span class="line">│   ├── model（模型目录）</span><br><span class="line">│   ├── public（公共文件目录）</span><br><span class="line">│   ├── routers（路由目录）</span><br><span class="line">│   ├── config.js（配置文件）</span><br><span class="line">│   └── index.js（应用入口）</span><br><span class="line">└── package.json（项目依赖包目录）</span><br></pre></td></tr></table></figure><h2 id="服务端功能实现-MongoDB"><a href="#服务端功能实现-MongoDB" class="headerlink" title="服务端功能实现(MongoDB)"></a>服务端功能实现(MongoDB)</h2><h3 id="意义"><a href="#意义" class="headerlink" title="意义"></a>意义</h3><p>为 WEB 应用提供可对数据库进行操作的接口服务。</p><h3 id="依赖包（插件）"><a href="#依赖包（插件）" class="headerlink" title="依赖包（插件）"></a>依赖包（插件）</h3><p>将服务端功能拆解，仅维护核心代码，其余功能由插件提供（保证了开发效率，及功能的更新维护）。</p><h4 id="生产依赖"><a href="#生产依赖" class="headerlink" title="生产依赖"></a>生产依赖</h4><ul><li>koa：基于 Node 开发的轻量级 WEB 应用框架，API 开发的利器；</li><li>koa-router：koa 的路由中间件，提供 Restful 资源路由；</li><li>koa-body：koa 请求体解析中间件，支持文件上传；</li><li>koa-json-error：koa2 错误处理中间件（json 形式返回错误），显示堆栈跟踪；</li><li>koa-parameter：koa 参数验证中间件；</li><li>koa-static：koa 静态文件服务中间件；</li><li>koa-jwt：koa jwt 认证中间件；</li><li>mongoose：MongoDB 对象建模工具，连接操作数据库；</li></ul><h4 id="开发依赖"><a href="#开发依赖" class="headerlink" title="开发依赖"></a>开发依赖</h4><ul><li>cross-env：设置环境变量（可跨平台）；</li></ul><h3 id="入口文件"><a href="#入口文件" class="headerlink" title="入口文件"></a>入口文件</h3><p>db-service &gt; app &gt; index.js</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> Koa = <span class="built_in">require</span>(<span class="string">'koa'</span>);                   <span class="comment">// 服务端采用的框架</span></span><br><span class="line"><span class="keyword">const</span> koaBody = <span class="built_in">require</span>(<span class="string">'koa-body'</span>);          <span class="comment">// 请求体解析中间件，支持文件上传</span></span><br><span class="line"><span class="keyword">const</span> koaStatic = <span class="built_in">require</span>(<span class="string">'koa-static'</span>);      <span class="comment">// 静态文件服务中间件</span></span><br><span class="line"><span class="keyword">const</span> error = <span class="built_in">require</span>(<span class="string">'koa-json-error'</span>);      <span class="comment">// 错误处理中间件</span></span><br><span class="line"><span class="keyword">const</span> parameter = <span class="built_in">require</span>(<span class="string">'koa-parameter'</span>);   <span class="comment">// 参数验证中间件</span></span><br><span class="line"><span class="keyword">const</span> mongoose = <span class="built_in">require</span>(<span class="string">'mongoose'</span>);         <span class="comment">// 连接操作 MongoDB</span></span><br><span class="line"><span class="keyword">const</span> path = <span class="built_in">require</span>(<span class="string">'path'</span>);                 <span class="comment">// Node 核心模块，提供路径服务</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> routers = <span class="built_in">require</span>(<span class="string">'./routers'</span>);         <span class="comment">// 路由文件</span></span><br><span class="line"><span class="keyword">const</span> &#123; connectionStr &#125; = <span class="built_in">require</span>(<span class="string">'./config'</span>);<span class="comment">// 连接参数文件</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> app = <span class="keyword">new</span> Koa;    <span class="comment">// 实例化：将抽象的类具体化，进而实现调用类中的功能</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* MongoDB 连接服务 */</span></span><br><span class="line">mongoose.connect(connectionStr, &#123; <span class="attr">useNewUrlParser</span>: <span class="literal">true</span>, <span class="attr">useUnifiedTopology</span>: <span class="literal">true</span> &#125;, () =&gt; &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'MongoDB connection succeeded !'</span>);</span><br><span class="line">&#125;);</span><br><span class="line">mongoose.connection.on(<span class="string">'error'</span>, <span class="built_in">console</span>.error);</span><br><span class="line">mongoose.set(<span class="string">'useFindAndModify'</span>, <span class="literal">false</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 静态文件服务 */</span></span><br><span class="line">app.use(koaStatic(path.join(__dirname, <span class="string">'public'</span>)));</span><br><span class="line"><span class="comment">/* 错误处理（生产环境不返回堆栈信息） */</span></span><br><span class="line">app.use(error(&#123;</span><br><span class="line">    postFormat: <span class="function">(<span class="params">err, &#123;stack, ...rest&#125;</span>) =&gt;</span> &#123;</span><br><span class="line">        <span class="keyword">if</span>(process.env.NODE_ENV === <span class="string">'production'</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> rest;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> &#123;stack, ...rest&#125;;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;));</span><br><span class="line"><span class="comment">/* 请求体解析，文件上传 */</span></span><br><span class="line">app.use(koaBody(&#123;</span><br><span class="line">    multipart: <span class="literal">true</span>,</span><br><span class="line">    formidable: &#123;</span><br><span class="line">        uploadDir: path.join(__dirname, <span class="string">'/public/uploads'</span>),</span><br><span class="line">        keepExtensions: <span class="literal">true</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;));</span><br><span class="line"><span class="comment">/* 添加 verifyParams 方法（控制器中会有体现），不添加 catch 中间件 */</span></span><br><span class="line">parameter(app);</span><br><span class="line"><span class="comment">/* 注册路由 */</span></span><br><span class="line">routers(app);</span><br><span class="line"><span class="comment">/* 在 3000 端口启动服务 */</span></span><br><span class="line">app.listen(<span class="number">3000</span>, () =&gt; &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'Starting with 3000 ···'</span>)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><h3 id="数据库连接配置文件"><a href="#数据库连接配置文件" class="headerlink" title="数据库连接配置文件"></a>数据库连接配置文件</h3><p>db-service &gt; app &gt; config.js</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">module</span>.exports = &#123;</span><br><span class="line">    secret: <span class="string">""</span>,    <span class="comment">// jwt 认证需要的参数（后期处理）</span></span><br><span class="line">    connectionStr: <span class="string">'mongodb+srv://admin:&lt;password&gt;@dbservice-ndhcg.mongodb.net/test?retryWrites=true&amp;w=majority'</span>    <span class="comment">// MongoDB 连接信息码（后期处理）</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="创建用户表组织结构"><a href="#创建用户表组织结构" class="headerlink" title="创建用户表组织结构"></a>创建用户表组织结构</h3><p>db-service &gt; app &gt; model &gt; user.js</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> mongoose = <span class="built_in">require</span>(<span class="string">'mongoose'</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> &#123;Schema, model&#125; = mongoose;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> userSchema = <span class="keyword">new</span> Schema(&#123;</span><br><span class="line">    name: &#123;</span><br><span class="line">        type: <span class="built_in">String</span></span><br><span class="line">    &#125;,</span><br><span class="line">    password: &#123;</span><br><span class="line">        type: <span class="built_in">String</span>,</span><br><span class="line">        select: <span class="literal">false</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="built_in">module</span>.exports = model(<span class="string">'User'</span>, userSchema);</span><br></pre></td></tr></table></figure><h3 id="控制器"><a href="#控制器" class="headerlink" title="控制器"></a>控制器</h3><p>db-service &gt; app &gt; controller &gt; home.js</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> path = <span class="built_in">require</span>(<span class="string">'path'</span>);</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">HomeCtrl</span> </span>&#123;</span><br><span class="line">    index(ctx) &#123;</span><br><span class="line">        ctx.body = <span class="string">"&lt;h1&gt;Home&lt;/h1&gt;"</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 上传接口</span></span><br><span class="line">    upload(ctx) &#123;</span><br><span class="line">        <span class="keyword">const</span> file = ctx.request.files.file;</span><br><span class="line">        <span class="keyword">const</span> basename = path.basename(file.path);</span><br><span class="line">        ctx.body = &#123;<span class="attr">url</span>: <span class="string">`<span class="subst">$&#123;ctx.origin&#125;</span>/uploads/<span class="subst">$&#123;basename&#125;</span>`</span>&#125;;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">module</span>.exports = <span class="keyword">new</span> HomeCtrl();</span><br></pre></td></tr></table></figure><h3 id="用户表控制器"><a href="#用户表控制器" class="headerlink" title="用户表控制器"></a>用户表控制器</h3><p>db-service &gt; app &gt; controller &gt; user.js</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> jwt = <span class="built_in">require</span>(<span class="string">'koa-jwt'</span>);         <span class="comment">// json web token 认证中间件</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> User = <span class="built_in">require</span>(<span class="string">'../model/user'</span>);  <span class="comment">// 用户表结构</span></span><br><span class="line"><span class="keyword">const</span> &#123;secret&#125; = <span class="built_in">require</span>(<span class="string">'../config'</span>);  <span class="comment">// jwt 签名所需要的参数</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">UserCtrl</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 增</span></span><br><span class="line">    <span class="keyword">async</span> create(ctx) &#123;</span><br><span class="line">        ctx.verifyParams(&#123;</span><br><span class="line">            name: &#123;</span><br><span class="line">                type: <span class="string">'string'</span></span><br><span class="line">            &#125;,</span><br><span class="line">            password: &#123;</span><br><span class="line">                type: <span class="string">'string'</span></span><br><span class="line">            &#125; </span><br><span class="line">        &#125;)</span><br><span class="line">        <span class="keyword">const</span> &#123;name&#125; = ctx.request.body;</span><br><span class="line">        <span class="keyword">const</span> repeatedUser = <span class="keyword">await</span> User.findOne(&#123;name&#125;);</span><br><span class="line">        <span class="keyword">if</span>(repeatedUser) &#123;ctx.throw(<span class="number">409</span>, <span class="string">'用户已存在！'</span>)&#125;;</span><br><span class="line">        <span class="keyword">const</span> user = <span class="keyword">await</span> <span class="keyword">new</span> User(ctx.request.body).save();</span><br><span class="line">        ctx.body = user;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 删</span></span><br><span class="line">    <span class="keyword">async</span> del(ctx) &#123;</span><br><span class="line">        <span class="keyword">const</span> user = <span class="keyword">await</span> User.findByIdAndRemove(ctx.params.id);</span><br><span class="line">        <span class="keyword">if</span>(!user) &#123;ctx.throw(<span class="number">404</span>, <span class="string">'用户不存在！'</span>)&#125;;</span><br><span class="line">        ctx.status = <span class="number">204</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 改</span></span><br><span class="line">    <span class="keyword">async</span> update(ctx) &#123;</span><br><span class="line">        ctx.verifyParams(&#123;</span><br><span class="line">            name: &#123;</span><br><span class="line">                type: <span class="string">'string'</span>,</span><br><span class="line">                required: <span class="literal">false</span></span><br><span class="line">            &#125;,</span><br><span class="line">            password: &#123;</span><br><span class="line">                type: <span class="string">'string'</span>,</span><br><span class="line">                required: <span class="literal">false</span></span><br><span class="line">            &#125; </span><br><span class="line">        &#125;)</span><br><span class="line">        <span class="keyword">const</span> user = <span class="keyword">await</span> User.findByIdAndUpdate(ctx.params.id, ctx.request.body);</span><br><span class="line">        <span class="keyword">if</span>(!user) &#123;ctx.throw(<span class="number">404</span>, <span class="string">'用户不存在！'</span>)&#125;</span><br><span class="line">        ctx.body = user;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 查询所有</span></span><br><span class="line">    <span class="keyword">async</span> find(ctx) &#123;</span><br><span class="line">        ctx.body = <span class="keyword">await</span> User.find();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 查询特定用户</span></span><br><span class="line">    <span class="keyword">async</span> findById(ctx) &#123;</span><br><span class="line">        <span class="keyword">const</span> user = <span class="keyword">await</span> User.findById(ctx.params.id);</span><br><span class="line">        <span class="keyword">if</span>(!user) &#123;ctx.throw(<span class="number">404</span>, <span class="string">'用户不存在！'</span>)&#125;</span><br><span class="line">        ctx.body = user;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 登录</span></span><br><span class="line">    <span class="keyword">async</span> login(ctx) &#123;</span><br><span class="line">        ctx.verifyParams(&#123;</span><br><span class="line">            name: &#123;</span><br><span class="line">                type: <span class="string">'string'</span></span><br><span class="line">            &#125;,</span><br><span class="line">            password: &#123;</span><br><span class="line">                type: <span class="string">'string'</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;)</span><br><span class="line">        <span class="keyword">const</span> user = <span class="keyword">await</span> User.findOne(ctx.request.body);</span><br><span class="line">        <span class="keyword">if</span>(!user) &#123;ctx.throw(<span class="number">401</span>, <span class="string">'用户名或密码不正确！'</span>)&#125;</span><br><span class="line">        <span class="keyword">const</span> &#123;_id, name&#125; = user;</span><br><span class="line">        <span class="keyword">const</span> token = jwt.sign(&#123;_id, name&#125;, secret, &#123;<span class="attr">expiresIn</span>: <span class="string">'1d'</span>&#125;);</span><br><span class="line">        ctx.body = &#123;token&#125;;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 认证</span></span><br><span class="line">    auth = jwt(&#123;secret&#125;);</span><br><span class="line">    <span class="comment">// 授权</span></span><br><span class="line">    <span class="keyword">async</span> checkOwner(ctx, next) &#123;</span><br><span class="line">        <span class="keyword">if</span>(ctx.params.id !== ctx.state.user._id) &#123;ctx.throw(<span class="number">403</span>, <span class="string">'没有权限！'</span>)&#125;</span><br><span class="line">        <span class="keyword">await</span> next();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">module</span>.exports = <span class="keyword">new</span> UserCtrl();</span><br></pre></td></tr></table></figure><h3 id="路由入口"><a href="#路由入口" class="headerlink" title="路由入口"></a>路由入口</h3><p>db-service &gt; app &gt; routers &gt; index.js</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> fs = <span class="built_in">require</span>(<span class="string">'fs'</span>);</span><br><span class="line"></span><br><span class="line"><span class="built_in">module</span>.exports = <span class="function">(<span class="params">app</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="comment">// 利用 fs 模块遍历注册路由</span></span><br><span class="line">    fs.readdirSync(__dirname).forEach(<span class="function">(<span class="params">file</span>) =&gt;</span> &#123;</span><br><span class="line">        <span class="keyword">if</span>(file !== <span class="string">'index.js'</span>) &#123;</span><br><span class="line">            <span class="keyword">const</span> router = <span class="built_in">require</span>(<span class="string">`./<span class="subst">$&#123;file&#125;</span>`</span>);</span><br><span class="line">            app.use(router.routes()).use(router.allowedMethods());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="主路由"><a href="#主路由" class="headerlink" title="主路由"></a>主路由</h3><p>db-service &gt; app &gt; routers &gt; home.js</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> Router = <span class="built_in">require</span>(<span class="string">'koa-router'</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> &#123;index, upload&#125; = <span class="built_in">require</span>(<span class="string">'../controller/home'</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> router = <span class="keyword">new</span> Router();</span><br><span class="line"></span><br><span class="line">router.get(<span class="string">'/'</span>, index);</span><br><span class="line">router.post(<span class="string">'/upload'</span>, upload);</span><br><span class="line"></span><br><span class="line"><span class="built_in">module</span>.exports = router;</span><br></pre></td></tr></table></figure><h3 id="用户路由"><a href="#用户路由" class="headerlink" title="用户路由"></a>用户路由</h3><p>db-service &gt; app &gt; routers &gt; user.js</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> Router = <span class="built_in">require</span>(<span class="string">'koa-router'</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> &#123;create, del, update, find, findById, login, auth, checkOwner&#125; = <span class="built_in">require</span>(<span class="string">'../controller/user'</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> usersRouter = <span class="keyword">new</span> Router(&#123;<span class="attr">prefix</span>: <span class="string">'/users'</span>&#125;); <span class="comment">// ‘/’代表‘/users’</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">usersRouter.post(<span class="string">'/'</span>, create);</span><br><span class="line">usersRouter.delete(<span class="string">'/:id'</span>, auth, checkOwner, del);</span><br><span class="line">usersRouter.patch(<span class="string">'/:id'</span>, auth, checkOwner, update);</span><br><span class="line">usersRouter.get(<span class="string">'/'</span>, find);</span><br><span class="line">usersRouter.get(<span class="string">'/:id'</span>, findById);</span><br><span class="line">usersRouter.post(<span class="string">'/login'</span>, login);</span><br><span class="line"></span><br><span class="line"><span class="built_in">module</span>.exports = usersRouter;</span><br></pre></td></tr></table></figure><p>更新中······</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&amp;emsp;&amp;emsp;将 Node 项目中的数据库服务解耦，上传至 NPM 平台，方便之后项目复用。&lt;/p&gt;
&lt;h2 id=&quot;技能要求&quot;&gt;&lt;a href=&quot;#技能要求&quot; class=&quot;headerlink&quot; title=&quot;技能要求&quot;&gt;&lt;/a&gt;技能要求&lt;/h2&gt;&lt;ul&gt;
&lt;
      
    
    </summary>
    
      <category term="项目实例" scheme="http://huishanyi.club/categories/%E9%A1%B9%E7%9B%AE%E5%AE%9E%E4%BE%8B/"/>
    
    
      <category term="NodeJS" scheme="http://huishanyi.club/tags/NodeJS/"/>
    
      <category term="数据库" scheme="http://huishanyi.club/tags/%E6%95%B0%E6%8D%AE%E5%BA%93/"/>
    
      <category term="服务端搭建" scheme="http://huishanyi.club/tags/%E6%9C%8D%E5%8A%A1%E7%AB%AF%E6%90%AD%E5%BB%BA/"/>
    
  </entry>
  
  <entry>
    <title>ESLint</title>
    <link href="http://huishanyi.club/2020/03/04/%E4%BB%A3%E7%A0%81%E8%A7%84%E8%8C%83/ESLint/"/>
    <id>http://huishanyi.club/2020/03/04/代码规范/ESLint/</id>
    <published>2020-03-04T00:46:58.000Z</published>
    <updated>2020-07-07T21:45:28.628Z</updated>
    
    <content type="html"><![CDATA[<p>&emsp;&emsp;ESLint 是一个开源的、提供插件化的 javascript 代码检测工具，初衷是为了让程序员可以创建自己的检测规则。它内置了一些流行代码规则，也可以自定义代码规则，让你的代码更加规范，使团队的代码更加统一。<br>&emsp;&emsp;ESLint 由 Nicholas C. Zakas 于2013年6月创建。若需详细了解 ESLint，请浏览 <a href="https://eslint.org/" target="_blank">ESLint 官方文档</a>，<a href="https://eslint.bootcss.com/" target="_blank">ESLint 汉化文档</a>。</p><h2 id="为什么要使用-ESLint-？"><a href="#为什么要使用-ESLint-？" class="headerlink" title="为什么要使用 ESLint ？"></a>为什么要使用 ESLint ？</h2><ul><li>统一团队代码，减少沟通成本；</li><li>插拔式代码规则，自由选取；</li><li>配置简单，快速实用。</li></ul><h2 id="环境"><a href="#环境" class="headerlink" title="环境"></a>环境</h2><ul><li>支持 ESLint 插件的编辑器（VSCode、Sublime、Atom、WebStorm···）</li><li>Node v5.2.0+(主版本号已经是两位数了，老旧版本没必要重提，此类版本保证了 npx 的正常使用)</li></ul><h2 id="React-项目配置-ESLint"><a href="#React-项目配置-ESLint" class="headerlink" title="React 项目配置 ESLint"></a>React 项目配置 ESLint</h2><ol><li>进入项目根目录；</li><li>运行<code>npx eslint --init</code>初始化；<ul><li>How would you like to use ESLint? <ul><li>To check syntax, find problems, and enforce code style</li></ul></li><li>What type of modules does your project use?<ul><li>JavaScript modules (import/export)</li></ul></li><li>Which framework does your project use?<ul><li>React</li></ul></li><li>Does your project use TypeScript? (y/N)<ul><li>N（取决于你是否使用TypeScript）</li></ul></li><li>Where does your code run?（多选，空格选取，回车确定，取决于你的项目运行环境）<ul><li>（*）Browser（空格后括号中会出现 *）</li><li>（*）Node</li></ul></li><li>How would you like to define a style for your project?<ul><li>Use a popular style guide（使用主流代码风格，==推荐==）</li><li>Answer questions about your style（问答形式生成代码风格）</li><li>Inspect your JavaScript file(s)（检查已有 JS 文件生成代码风格）</li></ul></li><li>Which style guide do you want to follow?（上一步选择的是主流代码风格）<ul><li>Airbnb: <a href="https://github.com/airbnb/javascript" target="_blank" rel="noopener">https://github.com/airbnb/javascript</a> （推荐，97.6k star）</li><li>Standard: <a href="https://github.com/standard/standard" target="_blank" rel="noopener">https://github.com/standard/standard</a> （24k star）</li><li>Google: <a href="https://github.com/google/eslint-config-google" target="_blank" rel="noopener">https://github.com/google/eslint-config-google</a> （1.3k star）</li></ul></li><li>What format do you want your config file to be in? （生成的 ESLint 配置文件格式）<ul><li>JavaScript（个人习惯）</li><li>YAML</li><li>JSON</li></ul></li><li>Would you like to install them now with npm? <ul><li>Y（安装依赖）</li></ul></li></ul></li><li>ESLint 初始化完成，项目根目录将生成<code>.eslintrc.js</code>文件（配置代码规则）。</li><li>进行编辑器配置，以 VSCode 为例，安装 ESLint 插件即可。</li><li>完成上述操作，打开项目文件，从此代码变美丽！</li></ol><h2 id="VSCode-自动格式化代码"><a href="#VSCode-自动格式化代码" class="headerlink" title="VSCode 自动格式化代码"></a>VSCode 自动格式化代码</h2><ul><li><p>安装 EsLint 插件</p></li><li><p>选择<code>File（文件） =&gt; Preference（首选项） =&gt; Settings（设置）</code></p></li><li><p>搜索 eslint</p></li><li><p>点击 Edit in setting.json（在 setting.json 中编辑）</p></li><li><p>添加如下配置（2019 提交的版本）</p><ul><li><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">"eslint.autoFixOnSave": true,</span><br><span class="line">"eslint.validate": [</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="attr">"language"</span>: <span class="string">"vue"</span>,</span><br><span class="line">        <span class="attr">"autoFix"</span>: <span class="literal">true</span></span><br><span class="line">    &#125;,</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="attr">"language"</span>: <span class="string">"html"</span>,</span><br><span class="line">        <span class="attr">"autoFix"</span>: <span class="literal">true</span></span><br><span class="line">    &#125;,</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="attr">"language"</span>: <span class="string">"javascript"</span>,</span><br><span class="line">        <span class="attr">"autoFix"</span>: <span class="literal">true</span></span><br><span class="line">    &#125;,</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="attr">"language"</span>: <span class="string">"typescript"</span>,</span><br><span class="line">        <span class="attr">"autoFix"</span>: <span class="literal">true</span></span><br><span class="line">    &#125;,</span><br><span class="line">],</span><br></pre></td></tr></table></figure></li></ul></li><li><p>添加如下配置（2020 提交的版本）</p><ul><li><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">"editor.codeActionsOnSave": &#123;</span><br><span class="line">    "source.fixAll.eslint": true,</span><br><span class="line">&#125;,</span><br></pre></td></tr></table></figure></li></ul></li></ul><h2 id="ESLint-问题汇总"><a href="#ESLint-问题汇总" class="headerlink" title="ESLint 问题汇总"></a>ESLint 问题汇总</h2><h3 id="ESLint-在-VSCode-中不生效"><a href="#ESLint-在-VSCode-中不生效" class="headerlink" title="ESLint 在 VSCode 中不生效"></a>ESLint 在 VSCode 中不生效</h3><p><strong>问题描述</strong><br>VSCode 中 ESLint 插件已正常安装，项目初始化完成，打开项目文件发现 ESLint 不生效。</p><p><strong>产生原因</strong><br>VSCode 中 ESLint 插件默认读取 WORKSPACE 下项目根目录下的<code>.eslintrc.js</code>，请勿将自己创建的项目汇总目录添加至 VSCode 中。</p><p><strong>解决方案</strong><br>项目目录在 VSCode 中外层不要包裹文件夹。<br>正确目录格式：</p><p><img src="/images/eslint_vscode_right_category.png" alt="正确目录格式" title="正确目录格式">  </p><p>错误目录格式：<br><img src="/images/eslint_vscode_err_category.png" alt="错误目录格式" title="错误目录格式">  </p><h3 id="Expected-linebreaks-to-be-‘LF’-but-found-‘CRLF’"><a href="#Expected-linebreaks-to-be-‘LF’-but-found-‘CRLF’" class="headerlink" title="Expected linebreaks to be ‘LF’ but found ‘CRLF’"></a>Expected linebreaks to be ‘LF’ but found ‘CRLF’</h3><p><strong>问题描述</strong><br>文件中报错<code>Expected linebreaks to be &#39;LF&#39; but found &#39;CRLF&#39;</code>。</p><p><strong>产生原因</strong><br>系统换行符异常。</p><p><strong>解决方案</strong><br><code>.eslintrc.js</code>文件中添加下述代码：</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">rules: &#123;</span><br><span class="line">    // 解决 Expected linebreaks to be 'LF' but found 'CRLF'. 报错</span><br><span class="line">    "linebreak-style": [0 ,"error", "windows"], </span><br><span class="line">  &#125;,</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&amp;emsp;&amp;emsp;ESLint 是一个开源的、提供插件化的 javascript 代码检测工具，初衷是为了让程序员可以创建自己的检测规则。它内置了一些流行代码规则，也可以自定义代码规则，让你的代码更加规范，使团队的代码更加统一。&lt;br&gt;&amp;emsp;&amp;emsp;ESLi
      
    
    </summary>
    
      <category term="前端" scheme="http://huishanyi.club/categories/%E5%89%8D%E7%AB%AF/"/>
    
    
      <category term="代码规范" scheme="http://huishanyi.club/tags/%E4%BB%A3%E7%A0%81%E8%A7%84%E8%8C%83/"/>
    
  </entry>
  
  <entry>
    <title>计算机组成与结构</title>
    <link href="http://huishanyi.club/2020/02/05/%E7%B3%BB%E7%BB%9F%E5%88%86%E6%9E%90%E5%B8%88/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E4%B8%8E%E7%BB%93%E6%9E%84/"/>
    <id>http://huishanyi.club/2020/02/05/系统分析师/计算机组成与结构/</id>
    <published>2020-02-04T22:38:40.000Z</published>
    <updated>2020-07-07T21:45:28.634Z</updated>
    
    <content type="html"><![CDATA[<p>&emsp;&emsp;介绍计算机硬件组成及功能、计算机系统结构及系统可靠性分析。</p><h2 id="计算机硬件组成"><a href="#计算机硬件组成" class="headerlink" title="计算机硬件组成"></a>计算机硬件组成</h2><ul><li>运算器</li><li>控制器</li><li>存储器<ul><li>内部存储器：容量小，速度快，临时存放数据；</li><li>外部存储器：容量大，速度慢，长期保存数据。</li></ul></li><li>输入设备（鼠标键盘）</li><li>输出设备（显示器）</li></ul><h2 id="中央处理单元"><a href="#中央处理单元" class="headerlink" title="中央处理单元"></a>中央处理单元</h2><p>CPU，Central Processing unit。<br>组成：运算器，控制器，寄存器组，内部总线。<br>功能：程序控制，操作控制，时间控制，数据处理。</p><h3 id="运算器"><a href="#运算器" class="headerlink" title="运算器"></a>运算器</h3><h4 id="组成"><a href="#组成" class="headerlink" title="组成"></a>组成</h4><ul><li>算术逻辑单元（ALU，Arithmetic and Logic Unit）：数据的算数和逻辑运算；</li><li>累加器：（AC，Accumulator ）：运算结果或源操作数的存放区；</li><li>数据缓冲寄存器（DR，Data Register）：暂时存放内存的指令或数据；</li><li>状态条件寄存器（PSW，Program Status Word）：保存指令运行结果的条件吗内容，如进位标志、溢出标志等。</li></ul><h4 id="功能"><a href="#功能" class="headerlink" title="功能"></a>功能</h4><ul><li>算术运算（加减乘除等）；</li><li>逻辑运算并逻辑测试（与、或、非、比较等）。</li></ul><h3 id="控制器"><a href="#控制器" class="headerlink" title="控制器"></a>控制器</h3><h4 id="组成-1"><a href="#组成-1" class="headerlink" title="组成"></a>组成</h4><ul><li>指令寄存器（IR，Instruction Register）：暂存 CPU 执行指令；</li><li>程序计数器（PC，Program Counter）：存放指令执行地址；</li><li>地址寄存器（AR，Address Register）：保存当前 CPU 访问的内存地址；</li><li>指令译码器（ID，Instruction Decoder）：分析指令操作码。</li></ul><h4 id="功能-1"><a href="#功能-1" class="headerlink" title="功能"></a>功能</h4><p>控制整个 CPU 的工作，最为重要。</p><ul><li>程序控制</li><li>时序控制</li></ul><h2 id="数据表示"><a href="#数据表示" class="headerlink" title="数据表示"></a>数据表示</h2><h2 id="校验码"><a href="#校验码" class="headerlink" title="校验码"></a>校验码</h2><h2 id="指令系统"><a href="#指令系统" class="headerlink" title="指令系统"></a>指令系统</h2><h2 id="存储系统"><a href="#存储系统" class="headerlink" title="存储系统"></a>存储系统</h2><h2 id="总线结构"><a href="#总线结构" class="headerlink" title="总线结构"></a>总线结构</h2><h2 id="系统可靠性分析"><a href="#系统可靠性分析" class="headerlink" title="系统可靠性分析"></a>系统可靠性分析</h2>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&amp;emsp;&amp;emsp;介绍计算机硬件组成及功能、计算机系统结构及系统可靠性分析。&lt;/p&gt;
&lt;h2 id=&quot;计算机硬件组成&quot;&gt;&lt;a href=&quot;#计算机硬件组成&quot; class=&quot;headerlink&quot; title=&quot;计算机硬件组成&quot;&gt;&lt;/a&gt;计算机硬件组成&lt;/h2&gt;&lt;ul&gt;
      
    
    </summary>
    
      <category term="系统分析师" scheme="http://huishanyi.club/categories/%E7%B3%BB%E7%BB%9F%E5%88%86%E6%9E%90%E5%B8%88/"/>
    
    
      <category term="系统分析师" scheme="http://huishanyi.club/tags/%E7%B3%BB%E7%BB%9F%E5%88%86%E6%9E%90%E5%B8%88/"/>
    
  </entry>
  
</feed>
